<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + GitHub Pages搭建个人免费博客</title>
    <url>/2021/05/11/Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>综合了很多种方案，平衡稳定、简洁等因素，最终还是决定使用<a href="https://hexo.io/zh-cn/">Hexo</a>+<a href="https://pages.github.com/">GitHub Pages</a>来搭建博客网站，虽然前期需要折腾一下，权当学习。</p>
<span id="more"></span>

<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>需要安装<a href="https://git-scm.com/downloads">Git</a>和<a href="https://nodejs.org/zh-cn/">Node.js</a>，安装完成(包括设置好环境变量后)，打开cmd或PowerShell，输入<code>node -v</code>、<code>npm -v</code>和<code>git --version</code>，如图出现程序版本号即可。<br><img src="/2021/05/11/Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/environment.png" alt="git及node.js环境测试" title="Git及node.js环境">  </p>
<h1 id="连接GitHub"><a href="#连接GitHub" class="headerlink" title="连接GitHub"></a>连接GitHub</h1><ol>
<li><p>创建<a href="https://github.com/">GitHub</a>账户，完成邮件验证。</p>
</li>
<li><p>任意位置右键 -&gt; Git Bash Here, 设置用户名和邮箱，或者打开C:\Users\用户名\.gitconfig编辑:</p>
<pre><code> git config --global user.name &quot;Github用户名&quot;  
 git config --global user.email &quot;Github邮箱&quot;  
</code></pre>
</li>
<li><p>创建SSH密钥：<br>输入<code>ssh-keygen -t rsa -C &quot;Github邮箱&quot;</code>，然后一路回车确认。</p>
</li>
<li><p>添加密钥：<br>进入C:\Users\用户名.ssh目录（要勾选显示“隐藏的项目”），用记事本打开公钥id_rsa.pub 文件并完整复制里面的内容。<br>登陆GitHub，进入Settings页面，选择左边栏的SSH and GPG keys，点击New SSH key。Title随便，粘贴复制的id_rsa.pub内容到Key中，点击Add SSH key完成添加。<br><img src="/2021/05/11/Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/Github_ssh_1.png" alt="GitHub ssh 1" title="Github添加ssh1"><br><img src="/2021/05/11/Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/Github_ssh_2.png" alt="GitHub ssh 2" title="Github添加ssh2"></p>
</li>
<li><p>验证连接:<br>打开Git Bash, 输入<code>ssh -T git@github.com</code>出现“Are you sure …”, 输入yes回车确认。<br>显示”Hi xxx! You’ve successfully authenticated, but GitHub does not …”即连接成功。后续再次输入此命令时，将不需要输入yes确认，直接显示成功。<br><img src="/2021/05/11/Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/Verify_Link_To_Github.png" alt="GitHub Link" title="连接Github">  </p>
</li>
</ol>
<h1 id="创建Github-Pages仓库"><a href="#创建Github-Pages仓库" class="headerlink" title="创建Github Pages仓库"></a>创建Github Pages仓库</h1><p>GitHub主页右上角点加号-&gt;New repository:</p>
<ul>
<li>Repository name 中输入 用户名.github.io</li>
<li>勾选 “Initialize this repository with a README”</li>
<li>Description 选填</li>
</ul>
<p>填好后点击Create repository创建。<br><img src="/2021/05/11/Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/CreateRepo.png" alt="GitHub create repository" title="Github创建一个仓库"></p>
<p>创建后默认自动启动HTTPS，博客地址为：<code>https://用户名.github.io</code></p>
<h1 id="本地安装Hexo博客程序"><a href="#本地安装Hexo博客程序" class="headerlink" title="本地安装Hexo博客程序"></a>本地安装Hexo博客程序</h1><p>新建一个文件夹用来存放Hexo的程序文件，如Hexo-Blog。进入该文件夹，右键-&gt;Git Bash Here。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>使用npm一键安装Hexo博客程序：</p>
<pre><code>npm install -g hexo-cli
</code></pre>
<p>耐心等待安装完成后回到输入界面。</p>
<h2 id="Hexo初始化及预览"><a href="#Hexo初始化及预览" class="headerlink" title="Hexo初始化及预览"></a>Hexo初始化及预览</h2><p>初始化并安装所需组件：</p>
<pre><code>hexo init   # 初始化
npm install # 安装组件
</code></pre>
<p>完成后依次输入以下命令，启动本地服务器进行预览：</p>
<pre><code>hexo g      # 生成页面
hexo s      # 启动预览
</code></pre>
<p>访问<code>http://localhost:4000</code>，出现Hexo默认页面，本地博客安装成功！<br><strong>Tips:</strong> 如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行<code>hexo server -p 5000</code>更改端口号后重试。</p>
<p>Hexo博客文件夹目录结构如下：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre>
<h2 id="部署Hexo到GitHub-Pages"><a href="#部署Hexo到GitHub-Pages" class="headerlink" title="部署Hexo到GitHub Pages"></a>部署Hexo到GitHub Pages</h2><p>本地博客测试成功后，再就是上传到GitHub进行部署，使其能够在网络上访问。<br>首先<strong>安装hexo-deployer-git:</strong></p>
<pre><code>npm install hexo-deployer-git --save
</code></pre>
<p>然后<strong>修改_config.yml</strong>文件末尾的Deployment部分：</p>
<pre><code>deploy:
    type: git
    repository: git@github.com:用户名/用户名.github.io.git
    branch: main
</code></pre>
<p>完成后运行hexo d将网站上传部署到GitHub Pages。<br>这时访问我们的GitHub域名<code>https://用户名.github.io</code>就可以看到上传的Hexo网站了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://hexo.io/zh-cn/" title="Hexo官网">Hexo - 快速、简洁且高效的博客框架</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/60578464" title="-知乎">使用 Hexo+GitHub 搭建个人免费博客教程（小白向）</a></li>
<li><a href="https://suyin-blog.club/2020/323EH2Y/" title="苏寅 Blog">Hexo-Next 主题安装并配置教程</a></li>
<li><a href="https://suyin-blog.club/2019/1YVTX5K/" title="苏寅 Blog">备份Hexo博客源文件</a></li>
<li><a href="https://blog.csdn.net/Wonz5130/article/details/84666519">解决 Hexo 搭建博客显示不出分类、标签问题</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习之一、 C++简介</title>
    <url>/2021/05/15/%E4%B8%80%E3%80%81C-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>开始学习 C++ 之前的一些认知。</p>
<span id="more"></span>

<h1 id="C-语言特点"><a href="#C-语言特点" class="headerlink" title="C++ 语言特点"></a>C++ 语言特点</h1><p>C++ 融合了 3 种不同的编程方式：</p>
<ul>
<li>C 语言代表的过程性编程。</li>
<li>C++ 在 C 语言基础上添加的类代表的面向对象（OOP）编程。</li>
<li>C++ 模板支持的泛型编程。</li>
</ul>
<h1 id="C-起源"><a href="#C-起源" class="headerlink" title="C++ 起源"></a>C++ 起源</h1><p>诞生于贝尔实验室，<strong>Bjarne Stroustrup</strong> 于 20 世纪 80 年代开发出了这种语言。基于 C 语言。</p>
<h1 id="C-标准"><a href="#C-标准" class="headerlink" title="C++ 标准"></a>C++ 标准</h1><ul>
<li>移植时需要对程序重新编译。</li>
<li>常用的两种标准，C++98, C++11 标准。</li>
</ul>
<h1 id="C-语言风格"><a href="#C-语言风格" class="headerlink" title="C++ 语言风格"></a>C++ 语言风格</h1><ul>
<li>源代码文件扩展名</li>
</ul>
<table>
<thead>
<tr>
<th>C++实现</th>
<th>源代码文件的扩展名</th>
</tr>
</thead>
<tbody><tr>
<td>UNIX</td>
<td>C、cc、cxx、c</td>
</tr>
<tr>
<td>GNU C++</td>
<td>C、cc、cxx、cpp、c++</td>
</tr>
<tr>
<td>Digital Mars</td>
<td>cpp、cxx</td>
</tr>
<tr>
<td>Borland C++</td>
<td>cpp</td>
</tr>
<tr>
<td>Watcom</td>
<td>cpp</td>
</tr>
<tr>
<td>Microsoft Visual C++</td>
<td>cpp、cxx、cc</td>
</tr>
<tr>
<td>Freestyle CodeWarrior</td>
<td>cp、cpp、cc、cxx、c++</td>
</tr>
</tbody></table>
<ul>
<li>程序创建步骤</li>
</ul>
<p><img src="https://p29.douyinpic.com/obj/toutiao.cg.fiji/c2rocm7qq1srh5grt570.png" alt="程序创建步骤" title="程序创建"></p>
<ul>
<li><p>C++ 编译</p>
<p>  常用编译器有 <code>gcc g++</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习之二、C++程序基本结构概述</title>
    <url>/2021/05/16/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C%E3%80%81C-%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>C++ 程序的基本结构概述，如函数和类。</p>
<span id="more"></span>

<p>示例1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simpmul.cpp ------ 文件名存储后缀为 .cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// C++ 预处理</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simpMul</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  <span class="comment">// main 函数，程序入口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> table = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">simpMul</span>(table);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// main() 函数返回值，main() 函数默认返回 0，也可省略此语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 简易乘法表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simpMul</span><span class="params">(<span class="keyword">int</span> table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= table; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; i*j &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-注释"><a href="#C-注释" class="headerlink" title="C++ 注释"></a>C++ 注释</h1><p>C++ 注释以 // 打头，到行尾结束。也可以位于单独的一行上。</p>
<p>C++ 也支持 C 风格的注释，C 注释包括在符号 /* 和 */ 之间，如：<code>/* 简易乘法表 */</code>。</p>
<h1 id="C-预处理和-iostream-文件"><a href="#C-预处理和-iostream-文件" class="headerlink" title="C++ 预处理和 iostream 文件"></a>C++ 预处理和 iostream 文件</h1><p>C++ 提供了两个用于处理输入和输出的预定义对象（ <code>cin</code> 和 <code>cout</code> ），它们是 <code>istream</code> 和 <code>ostream</code> 类的实例，这两个类是在 <code>iostream</code> 文件中定义的。</p>
<p>像 <code>iostream</code> 这样的文件叫做包含文件（ include file ），也叫头文件（ header file ），C 语言的传统是头文件使用扩展名 h，但 C++ 用法不同。现在，对老式 C 的头文件保留了扩展名 h （ C++ 程序仍然可以使用这种文件），而 C++ 头文件则没有扩展名。有些 C 头文件被转换为 C++ 头文件，这些文件被重新命名，去掉了扩展名 h （使之成为 C++ 风格的名称），并在文件名称前面加上前缀 c （表明来自 C 语言）。例如，C++ 版本的 math.h 为 cmath。有时 C 头文件的 C 版本和 C++ 版本相同，而有时候新的版本做了一些修改。对于纯粹的 C++ 头文件（如 <code>iostream</code>）来说，去掉 h 不只是形式上的变化，没有 h 的头文件也可以包含名称空间。下表对头文件的命名约定进行了总结。</p>
<table>
<thead>
<tr>
<th>头文件类型</th>
<th>约定</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>C++ 旧式风格</td>
<td>以 .h 结尾</td>
<td>iostream.h</td>
<td>C++ 程序可以使用</td>
</tr>
<tr>
<td>C 旧式风格</td>
<td>以 .h 结尾</td>
<td>math.h</td>
<td>C、C++ 程序可以使用，因为 C++ 兼容 C</td>
</tr>
<tr>
<td>C++ 新式风格</td>
<td>没有扩展名</td>
<td>iostream</td>
<td>C++ 程序可以使用，使用 namespace std</td>
</tr>
<tr>
<td>转换后的C</td>
<td>加上前缀 c ，没有扩展名</td>
<td>cmath</td>
<td>C++ 程序可以使用，可以使用不是 C 的特性，如 namespace std</td>
</tr>
</tbody></table>
<h1 id="名称空间-namespace"><a href="#名称空间-namespace" class="headerlink" title="名称空间 namespace"></a>名称空间 namespace</h1><p>名称空间支持是一项 C++ 特性，为了区分不同封装产品中的相同函数。使用情况如下。</p>
<h2 id="使用-using-namespace-xxx"><a href="#使用-using-namespace-xxx" class="headerlink" title="使用 using namespace xxx"></a>使用 using namespace xxx</h2><p>如使用 <code>using namespace std</code> 编译指令包含该名称空间，后续使用该空间中的对象或方法可以直接使用，如 <code>cout</code>，<code>cin</code>，<code>endl</code> 等。</p>
<h2 id="使用-using-xxx-xx"><a href="#使用-using-xxx-xx" class="headerlink" title="使用 using xxx::xx"></a>使用 using xxx::xx</h2><p>使用 <code>using</code> 指令只包含名称空间中的特定对象或方法，后续可以直接使用这些对象或方法，其它需要引用命名空间对象。<br>如使用 <code>using std::cout</code> ，后面可以直接使用 <code>cout</code>，但是没有使用该指令的，如 <code>endl</code>，就需要引用名称空间 <code>std::endl</code>。</p>
<h2 id="不使用-using-编译指令"><a href="#不使用-using-编译指令" class="headerlink" title="不使用 using 编译指令"></a>不使用 using 编译指令</h2><p>不使用任何 <code>using</code> 指令，在需要使用名称空间中对象或方法时，需要引用名称空间。<br>如 <code>std::cout</code>, <code>std::cin</code>, <code>std::endl</code></p>
<h1 id="C-函数原型与函数定义"><a href="#C-函数原型与函数定义" class="headerlink" title="C++ 函数原型与函数定义"></a>C++ 函数原型与函数定义</h1><ul>
<li><p>函数原型：用于描述函数接口，描述函数的参数及返回值信息，头文件中的内容就是函数原型，没有具体的函数代码。</p>
</li>
<li><p>函数定义：具体的函数实现代码，一般包含于库文件中。</p>
</li>
</ul>
<p><strong>Tips:</strong> C++ 程序应当为程序中使用的每个函数提供原型。</p>
<p>函数原型之于函数就像变量声明之于变量–指出涉及的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span>)</span></span>;    <span class="comment">// 函数原型，没有具体代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> d)</span>   <span class="comment">// 函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 具体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习之三、C++基本数据类型</title>
    <url>/2021/05/17/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%89%E3%80%81C-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>C++ 内置数据类型分两大类：<strong>基本数据类型</strong>和<strong>复合数据类型</strong>。本编介绍基本数据类型，又称算术（arithmetic）类型。</p>
<span id="more"></span>

<h1 id="基本数据类型–整型"><a href="#基本数据类型–整型" class="headerlink" title="基本数据类型–整型"></a>基本数据类型–整型</h1><p>整型是指没有小数部分的数字，如 2, 98, -376 和 0。术语宽度（ width ）用于描述存储整数时使用的内存量。使用的内存越多，则越宽。</p>
<p>C++ 的基本整型按宽度递增的顺序排列，分别有 <code>char</code>、<code>short</code>、<code>int</code>、<code>long</code> 和 C++11 新增的 <code>long long</code>，每种类型都有有符号和无符号版本，因此总共有 10 种类型可供选择。另外，ANSI/ISO C++ 还新增了一种特殊类型 <code>bool</code>。</p>
<h2 id="数值整型"><a href="#数值整型" class="headerlink" title="数值整型"></a>数值整型</h2><p>数值型整型包括 <code>short</code>、<code>int</code>、<code>long</code> 和 C++11 新增的 <code>long long</code>。</p>
<h3 id="整型宽度"><a href="#整型宽度" class="headerlink" title="整型宽度"></a>整型宽度</h3><p>概念：C++ 字节由至少能够容纳实现了基本字符集的相邻位组成。也就是说 C++ 一个字节可能意味着大于 8 bit，可能为 8，16 或 32 bit。</p>
<p>C++ 提供了一种灵活的标准，它确保了最小长度（从 C 语言借鉴而来）：</p>
<ul>
<li><code>short</code> 至少 16 位；</li>
<li><code>int</code> 至少与 <code>short</code> 一样长；</li>
<li><code>long</code> 至少 32 位，且至少与 <code>int</code> 一样长；</li>
<li><code>long long</code> 至少 64 位，且至少与 <code>long</code> 一样长。</li>
</ul>
<p><strong>Tips:</strong> 上述 4 种整型都有一种不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值，只需使用关键字 <code>unsigned</code> 来声明即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> n_short; <span class="comment">// 无符号 short 类型</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> n_int; <span class="comment">// 无符号 int 类型</span></span><br><span class="line"><span class="keyword">unsigned</span> n_int; <span class="comment">// int 可省略，仍然为无符号 int 类型</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> n_long;   <span class="comment">// 无符号 long 类型</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n_llong; <span class="comment">// 无符号 long long 类型</span></span><br></pre></td></tr></table></figure>

<p>可使用运算符 <code>sizeof</code> 确定数据类型的宽度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;int is &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">int</span>) &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int is &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> n_int &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>limits</code> 头文件通过预编译（#define）方式，提供了一些符号常量用以确定数据类型的取值范围：</p>
<table>
<thead>
<tr>
<th>符号常量</th>
<th>表示</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR_BIT</td>
<td>char 的位数</td>
</tr>
<tr>
<td>CHAR_MAX</td>
<td>char 的最大值</td>
</tr>
<tr>
<td>CHAR_MIN</td>
<td>char 的最小值</td>
</tr>
<tr>
<td>SCHAR_MAX</td>
<td>signed char 的最大值</td>
</tr>
<tr>
<td>SCHAR_MIN</td>
<td>signed char 的最小值</td>
</tr>
<tr>
<td>UCHAR_MAX</td>
<td>unsigned char 的最大值</td>
</tr>
<tr>
<td>SHRT_MAX</td>
<td>short 的最大值</td>
</tr>
<tr>
<td>SHRT_MIN</td>
<td>short 的最小值</td>
</tr>
<tr>
<td>USHRT_MAX</td>
<td>unsigned short 的最大值</td>
</tr>
<tr>
<td>INT_MAX</td>
<td>int 的最大值</td>
</tr>
<tr>
<td>INT_MIN</td>
<td>int 的最小值</td>
</tr>
<tr>
<td>UINT_MAX</td>
<td>unsigned int 的最大值</td>
</tr>
<tr>
<td>LONG_MAX</td>
<td>long 的最大值</td>
</tr>
<tr>
<td>LONG_MIN</td>
<td>long 的最小值</td>
</tr>
<tr>
<td>ULONG_MAX</td>
<td>unsigned long 的最大值</td>
</tr>
<tr>
<td>LLONG_MAX</td>
<td>long long 的最大值</td>
</tr>
<tr>
<td>LLONG_MIN</td>
<td>long long 的最小值</td>
</tr>
<tr>
<td>ULLONG_MAX</td>
<td>unsigned long long 的最大值</td>
</tr>
</tbody></table>
<h3 id="选择整型类型"><a href="#选择整型类型" class="headerlink" title="选择整型类型"></a>选择整型类型</h3><p>C++ 提供了如此多的整型，使用时应该怎么去选择呢？</p>
<ul>
<li>通常，<code>int</code> 被设置为对目标计算机而言最为“自然”的长度，计算机处理起来效率最高。如果没有其它理由，则应使用 <code>int</code>。</li>
<li>如果变量表示的值不可能为负，则可以使用无符号类型，这样变量可以表示更大的值。</li>
<li>如果变量表示的整数值可能大于 16 位整数的最大值，则使用 <code>long</code>。即使系统上 <code>int</code> 为 32 位也应该这样做。这样，将程序移植到 <code>int</code> 为 16 位的系统时，就不会突然无法正常工作。</li>
<li>如果要存储的值超过 20 亿，可使用 <code>long long</code>。</li>
<li>由于 <code>short</code> 比 <code>int</code> 小，使用 <code>short</code> 可以节省内存。通常，仅当有大型整型数组时，才有必要使用 <code>short</code>。如果节省内存很重要，则应使用 <code>short</code> 而不是使用 <code>int</code>。</li>
</ul>
<h3 id="整型字面值"><a href="#整型字面值" class="headerlink" title="整型字面值"></a>整型字面值</h3><ol>
<li><p>整型字面值，常用为四种不同的计数方式：</p>
<ul>
<li>十进制：第一位为 1~9，如 53</li>
<li>二进制：所有位都以 0 和 1 来表示，如 0101 等于十进制中 6</li>
<li>八进制：第一位为 0，第二位为 1~7，如 042 等于十进制中的 34</li>
<li>十六进制：前两位为 0x 或 0X，如 0x42 等于十进制的 66</li>
</ul>
<p> 进制计数只是为了人为的计数方便，在计算机中，数据最终都是以二进制存储。</p>
<p> <strong>Tips:</strong> <code>cout</code> 输出默认为十进制，<code>cout</code> 提供了控制符来控制显示 <code>dec</code>、<code>hex</code>、<code>oct</code>。具体如下：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>;</span><br><span class="line">cout &lt;&lt; a;  <span class="comment">// 默认打印为十进制：42</span></span><br><span class="line">cout &lt;&lt; hex;    <span class="comment">// 切换输出为十六进制</span></span><br><span class="line">cout &lt;&lt; a;  <span class="comment">// 输出打印为十六进制 2a</span></span><br><span class="line">cout &lt;&lt; oct;    <span class="comment">// 切换输出为八进制</span></span><br><span class="line">cout &lt;&lt; a;  <span class="comment">// 输出打印为八进制 52</span></span><br><span class="line">cout &lt;&lt; dec;    <span class="comment">// 切换输出为十进制</span></span><br><span class="line">cout &lt;&lt; a;  <span class="comment">// 输出打印为十进制 42；</span></span><br></pre></td></tr></table></figure></li>
<li><p>C++ 如何确定常量的类型</p>
<p> 如程序是如何确定常量 1000 是存储为 <code>int</code>、<code>long</code> 还是其它类型呢？</p>
<ol>
<li>默认存储为 <code>int</code>。</li>
<li>数值后的后缀。后缀有 L(Long)、U(Unsigned int)、LL(long long) 及组合后缀。</li>
<li>数值的长度。在 C++ 中，对十进制整数采用的规则与十六进制及八进制的不同。对于不带后缀的十进制整数，使用 <code>int</code>、<code>long</code>、<code>long long</code> 中能够存储该数的最小类型来表示。对于不带后缀的十六进制或八进制，使用下面几种类型中能够存储该数的最小类型来表示：<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code> 或 <code>unsigned long long</code>。</li>
</ol>
</li>
</ol>
<h2 id="另一种整型-char-类型"><a href="#另一种整型-char-类型" class="headerlink" title="另一种整型- char 类型"></a>另一种整型- char 类型</h2><p><code>char</code> 是比 <code>short</code> 更小的整型，专为存储字符（字母或数字）而设计。它足够长，能够表示目标计算机系统中所有的基本符号——所有的字母、数字、标点符号。一般占用 8 位。</p>
<h3 id="char-类型特点"><a href="#char-类型特点" class="headerlink" title="char 类型特点"></a>char 类型特点</h3><p><code>char</code> 在默认情况下<strong>既不是没有符号</strong>，<strong>也不是有符号</strong>。是否有符号由 <code>C++</code> 实现决定，这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来。如果 <code>char</code> 有某种特定的行为对您来说非常重要，则可以显示地将类型设置为 <code>signed char</code> 或 <code>unsigned char</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> fodo;  <span class="comment">// 可能有符号，也可能是无符号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bar;  <span class="comment">// 显式定义为无符号类型</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> snark;  <span class="comment">// 显式定义为有符号类型</span></span><br></pre></td></tr></table></figure>

<p><code>char</code> 类型变量初始化使用单引号：<code>char c = &#39;M&#39;</code></p>
<p>C++ 将字符表示为整数，可以进行算术运算。如 <code>char c = &#39;M&#39; + 1;</code></p>
<p>使用 <code>cin</code> 输入时都是输入的字符，然后强转为其它类型存储。</p>
<h3 id="char-字面值"><a href="#char-字面值" class="headerlink" title="char 字面值"></a>char 字面值</h3><ul>
<li>以单引号括起来。如 <code>&#39;M&#39;</code>、<code>&#39;N&#39;</code>、<code>&#39;&#39;</code>、<code>&#39;5&#39;</code></li>
<li>不能直接通过键盘输入的字符使用转义序列。如<code>&#39;\a&#39;</code>、<code>&#39;\t&#39;</code>、<code>&#39;\n&#39;</code><br>C++ 转义序列的编码</li>
</ul>
<table>
<thead>
<tr>
<th>字符名称</th>
<th>ASCII 符号</th>
<th>C++ 代码</th>
<th>十进制 ASCII 编码</th>
<th>十六进制 ASCII 编码</th>
</tr>
</thead>
<tbody><tr>
<td>换行符</td>
<td>NL(LF)</td>
<td>\n</td>
<td>10</td>
<td>0xA</td>
</tr>
<tr>
<td>水平制表符</td>
<td>HT</td>
<td>\t</td>
<td>9</td>
<td>0x9</td>
</tr>
<tr>
<td>垂直制表符</td>
<td>VT</td>
<td>\v</td>
<td>11</td>
<td>0xB</td>
</tr>
<tr>
<td>退格</td>
<td>BS</td>
<td>\b</td>
<td>8</td>
<td>0x8</td>
</tr>
<tr>
<td>回车</td>
<td>CR</td>
<td>\r</td>
<td>13</td>
<td>0xD</td>
</tr>
<tr>
<td>振铃</td>
<td>BEL</td>
<td>\a</td>
<td>7</td>
<td>0x7</td>
</tr>
<tr>
<td>反斜杠</td>
<td>\</td>
<td>\\</td>
<td>92</td>
<td>0x5C</td>
</tr>
<tr>
<td>问号</td>
<td>?</td>
<td>\?</td>
<td>63</td>
<td>0x3F</td>
</tr>
<tr>
<td>单引号</td>
<td>‘</td>
<td>\‘</td>
<td>39</td>
<td>0x27</td>
</tr>
<tr>
<td>双引号</td>
<td>“</td>
<td>\“</td>
<td>34</td>
<td>0x22</td>
</tr>
</tbody></table>
<p><strong>Tips:</strong> 应该像处理常规字符那样处理转义字符（如 <code>\n</code>）。也就是说，将它们作为字符常量时，应用单引号括起来；将它们放在字符串中时，不要使用单引号。</p>
<p>可以基于字符的八进制和十六进制编码来使用转义序列。例如 <code>Ctrl+Z</code> 的 ASCII 码为 26，对应的八进制编码为 032，十六进制编码为 0x1a。可以用下面的转义序列来表示该字符：<code>\032</code> 或 <code>\0x1a</code>。将这些编码用单引号括起，可以得到相应的字符常量。</p>
<h3 id="char-引申-–-通用字符名"><a href="#char-引申-–-通用字符名" class="headerlink" title="char 引申 – 通用字符名"></a>char 引申 – 通用字符名</h3><p>C++ 实现支持基本的源字符集（可用来编写源代码的字符集），基本的执行字符集（程序执行期间可处理的字符，如换行、退格、振铃等），还有一种表示特殊字符的机制，提供扩展源字符和扩展执行字符集，它独立于任何特定的键盘，使用的是通用字符名（universal character name）。</p>
<p>通用字符名的用法类似于转义字符。以 <code>\u</code> 后面跟 4 个十六进制位 或 <code>\U</code> 后面跟 8 个十六进制位来表示。这些十六进制位表示的是字符的 <code>ISO 10646</code> 码点（<code>ISO 10646</code> 是一种正在制定的国际标准，为大量的字符提供数值编码）。</p>
<p>如果所用的实现支持扩展字符，则可以在标识符（如字符常量）和字符串中使用通用字符名。如</p>
<pre><code>int k\u00F6rper;
cout &lt;&lt; &quot;Let them eat g\u00E2teau.\n&quot;;
</code></pre>
<p><code>ö</code> 的 ISO 10646 码点为 00F6，而 <code>â</code> 的码点 00E2 。因此，上述代码将变量名设置为 <code>körper</code>，将显示下面的输出</p>
<pre><code>Let them eat gâteau.
</code></pre>
<p>如果系统不支持 ISO 10646，它将显示其它字符或 <code>gu00E2teau</code>，而不是 <code>â</code>。</p>
<h3 id="char-引申-–-wchar-t-宽字符类型"><a href="#char-引申-–-wchar-t-宽字符类型" class="headerlink" title="char 引申 – wchar_t 宽字符类型"></a>char 引申 – wchar_t 宽字符类型</h3><p><code>wchar_t</code> 宽字符类型是一种整数类型，它的长度和符号特征随实现而异。它有足够的空间，可以表示系统使用的<strong>最大扩展字符集</strong>。这种类型与另一种整型（底层[underlying]类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是 <code>unsigned short</code>，而在另一个系统中，则可能是 <code>int</code>。</p>
<p><code>cin</code> 和 <code>cout</code> 将输入和输出看作是 <code>char</code> 流，因此不适于用来处理 <code>wchar_t</code> 类型。 <code>iostream</code> 头文件的最新版本提供了作用相似的工具 - <code>wcin</code> 和 <code>wcout</code>，可用于处理 <code>wchar_t</code> 流。另外，可以通过加上前缀 <code>L</code> 来指示宽字符常量和宽字符串。</p>
<pre><code>wchar_t bob = L&#39;P&#39;; // 宽字符常量
wcout &lt;&lt; L&quot;tall&quot;;   // 输出宽字符串
</code></pre>
<h3 id="C-11-新增类型：char16-t-和-char32-t"><a href="#C-11-新增类型：char16-t-和-char32-t" class="headerlink" title="C++11 新增类型：char16_t 和 char32_t"></a>C++11 新增类型：char16_t 和 char32_t</h3><p>区别于 <code>wchar_t</code> 长度及符号由实现决定，<code>char16_t</code> 和 <code>char32_t</code> 长度分别为 16 位和 32 位，<strong>无符号类型</strong>。使用前缀 <code>u</code> 和 <code>U</code> 分别来表征这两种字符或字符串常量，如 <code>u&#39;C&#39;</code> <code>u&quot;work hard&quot;</code>，<code>U&#39;R&#39;</code> <code>U&quot;First try&quot;</code>.</p>
<p><code>char16_t</code> 和 <code>char32_t</code> 也有底层类型 —— 一种内置的整型，但底层类型可能随系统而异。</p>
<h2 id="bool-类型"><a href="#bool-类型" class="headerlink" title="bool 类型"></a>bool 类型</h2><p>ANSI/ISO C++ 标准添加了一种名叫 <code>bool</code> 的新类型，布尔变量的值可以是 <code>true</code> 或 <code>false</code>，这两个值都可以通过提升转换为 <code>int</code> 类型，<code>true</code> 被转换为 1，<code>false</code> 被转换为 0。</p>
<pre><code>bool is_ready = true;
</code></pre>
<p>任何数字值或指针值都可以被隐式转换为 bool 值。任何非零值都被转换为 <code>true</code>，而零被转换为 <code>false</code>。</p>
<h1 id="基本数据类型-–-浮点型"><a href="#基本数据类型-–-浮点型" class="headerlink" title="基本数据类型 – 浮点型"></a>基本数据类型 – 浮点型</h1><p>浮点数能够表示带小数部分的数字，如 3.14159, 23.56, 0.10 等。如果数字很大，无法表示为 <code>long</code> 类型，则可以使用浮点类型表示。浮点类型能够表示非常大或非常小的值，它们的内部表示方法与整数有天壤之别。</p>
<p>有效位（significant figure）是指十进制数字中有意义的位（从第一个非零数字开始算起）。例如，山脉高度为 14179 英尺，该数字使用了 5 个有效位，如果写成约 14000 英尺，则该有效位只有 2 位，其余的 3 位只不过是占位符而已。</p>
<p><strong>Tips:</strong> 0.00000000035 的有效位数为 2。</p>
<h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>C++ 按有效位数和允许的指数的最小范围从低到高分为 3 种浮点类型：<code>float</code>、<code>double</code>、<code>long double</code>。</p>
<h2 id="浮点数有效位数"><a href="#浮点数有效位数" class="headerlink" title="浮点数有效位数"></a>浮点数有效位数</h2><p>事实上，<code>C</code> 和 <code>C++</code> 对于有效位数的要求如下：</p>
<ul>
<li><code>float</code> 至少 32 位；</li>
<li><code>double</code> 至少 48 位，且不少于 <code>float</code>；</li>
<li><code>long double</code> 至少和 <code>double</code> 一样多；</li>
<li>以上三种类型的有效位数可以一样多。然而，通常，<code>float</code> 为 32 位，<code>double</code> 为 64 位，<code>long double</code> 为 80、96 或 128 位。</li>
<li>以上三种类型的指数范围至少是 -37 到 37。</li>
</ul>
<p>头文件 <code>cfloat</code> 或 <code>float.h</code> 对系统的限制作了说明（<code>cfloat</code> 是 C 语言的 <code>float.h</code> 文件的 C++ 版本）。下面列出 <code>Borland C++ Builder</code> 的 <code>float.h</code> 文件中一些批注项：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为对浮点型有效位的限制</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLT_DIG 6   <span class="comment">// float 类型，至少 6 位有效位数（针对十进制，下同）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBL_DIG 15  <span class="comment">// double 类型，至少 15 位有效位数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LDBL_DIG 18 <span class="comment">// long double 类型，至少 18 位有效位数</span></span></span><br></pre></td></tr></table></figure>

<h2 id="浮点数字面值"><a href="#浮点数字面值" class="headerlink" title="浮点数字面值"></a>浮点数字面值</h2><p>在程序中书写浮点常量时，程序将把它存储为哪种浮点类型呢？</p>
<ul>
<li><p>默认情况下，浮点常量将存储为 <code>double</code> 类型。</p>
<p>  如 <code>8.3 0.14 0.1e7 3.99e-5</code> 默认都是 <code>double</code> 类型</p>
</li>
<li><p>使用后缀存储为指定类型。<code>float</code> 后缀为 <code>f</code> 或 <code>F</code>，<code>long double</code> 后缀为 <code>l</code> 或 <code>L</code>。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.234f  // float 常量</span><br><span class="line">2.3E20F // float 常量</span><br><span class="line">2.2L    // long double 常量</span><br><span class="line">2.2     // 默认为 double 常量</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="浮点数优缺点"><a href="#浮点数优缺点" class="headerlink" title="浮点数优缺点"></a>浮点数优缺点</h2><p>与整数相比，浮点数有两大优点。首先，它们可以表示整数之间的值。其次，由于有缩放因子，它们可以表示更大的范围。缺点方面，浮点运算的速度通常比整数运算慢，且精度将降低。</p>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2021/05/17/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Git 常用的一些命令汇总，及相关用法。</p>
<span id="more"></span>

<h1 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h1><p>Git 是一个分布式版本控制系统，常用于软件代码的版本控制，在这个系统的控制下，所有提交过的操作都是可追溯的。</p>
<h2 id="Git-处理数据特点"><a href="#Git-处理数据特点" class="headerlink" title="Git 处理数据特点"></a>Git 处理数据特点</h2><p>Git 把数据看作是对小型文件系统的一系列快照。在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当前的全部文件创建一个快照并保存这个快照的索引。如果文件没有个性，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流。<br><img src="https://p3.douyinpic.com/obj/toutiao.cg.fiji/c2qsklnqq1srh5grop10.png" alt="Checkins Over Time" title="存储项目随时间改变的快照"></p>
<h2 id="Git-文件工作状态"><a href="#Git-文件工作状态" class="headerlink" title="Git 文件工作状态"></a>Git 文件工作状态</h2><p>Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。</p>
<blockquote>
<p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
<p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</p>
<p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</p>
</blockquote>
<p>Git 项目下文件大的方面分两个状态：未跟踪和已跟踪。</p>
<blockquote>
<p>未跟踪指未纳入 Git 管理的文件，Git 下没有该文件的记录，不识别该文件</p>
<p>已跟踪指已在 Git 管理下的文件，又区分为：已修改、已暂存和已提交状态。</p>
<blockquote>
<p>已修改，指文件被修改，但修改之后还没有暂存</p>
<p>已暂存，指被操作后的文件已被标记，将纳入下次提交</p>
<p>已提交，指该文件已被提交到 Git 仓库，仓库中目前的快照为当前状态。第一次 clone 下来的文件就处于这个状态</p>
</blockquote>
</blockquote>
<h1 id="配置及帮助"><a href="#配置及帮助" class="headerlink" title="配置及帮助"></a>配置及帮助</h1><h2 id="初次运行-Git-前的配置"><a href="#初次运行-Git-前的配置" class="headerlink" title="初次运行 Git 前的配置"></a>初次运行 Git 前的配置</h2><pre><code>git config --system // 系统配置文件，包含系统上每一个用户及他们仓库的通用配置
git config --global // 针对当前用户的配置，如 git config --global user.name &quot;Tom Zhou&quot; 配置用户名
git config --local  // 针对该仓库，需要进入某个 Git 仓库中才能使用该命令
git config &lt;key&gt;    // 查看某项配置，如 git config core.editor
git config --list   // 查看所有配置
git config --list --show-origin // 查看所有配置以及它们所在的文件
git config &lt;key&gt; --show-origin  // 查看某项配置以及它所在的文件
</code></pre>
<h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><p>有三种等价的方法可以找到 Git 命令的综合手册：</p>
<pre><code>git help &lt;verb&gt;     // 如 git help config
git &lt;verb&gt; --help   // 如 git add -h
man git-&lt;verb&gt;
</code></pre>
]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习之四、C++变量</title>
    <url>/2021/05/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E3%80%81C-%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>C++ 变量是什么，变量的作用，变量的其它功能。</p>
<span id="more"></span>

<h1 id="变量作用："><a href="#变量作用：" class="headerlink" title="变量作用："></a>变量作用：</h1><p>变量用来表征：</p>
<ul>
<li>信息将存储在哪里；</li>
<li>要存储什么值；</li>
<li>存储何种类型的信息；</li>
</ul>
<h1 id="变量名命名规则"><a href="#变量名命名规则" class="headerlink" title="变量名命名规则"></a>变量名命名规则</h1><ul>
<li>名称中只能使用字母字符、数字和下划线（_）。</li>
<li>名称中第一个字符不能是数字。</li>
<li>区分大小写。</li>
<li>不能将 C++ 关键字用作名称。</li>
<li>以两个下划线开头或以下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。</li>
<li>C++ 对于名称长度没有限制。</li>
</ul>
<h1 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h1><p>如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。</p>
<ul>
<li><p>常规方式：<code> int n_int = INT_MAX;</code> <code>int one = 1;</code></p>
</li>
<li><p>C++ 方式：<code> short n_short = &#123;SHRT_MAX&#125;;</code></p>
</li>
<li><p>C++11 新增方式：</p>
<pre><code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_int = &#123;INT_MAX&#125;;    <span class="comment">// 大括号初始化器</span></span><br><span class="line"><span class="keyword">int</span> n_int&#123;INT_MAX&#125;;   <span class="comment">// 可省略等号</span></span><br><span class="line"><span class="keyword">int</span> n_int&#123;&#125;;   <span class="comment">// 大括号可以不包含任何东西，这种情况将初始化为0</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h1 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h1><p><code>const</code> 等价于 C 语言中的 <code>define</code>，C++ 中推荐使用 <code>const</code> 来声明一个值不可变的变量，也即常量。</p>
<p><code>const</code> 与 <code>define</code> 相比的好处：</p>
<ul>
<li>它能够明确指定数据类型</li>
<li>C++ 作用域规则可将定义限制在特定的函数或文件中</li>
<li><code>const</code> 可用于更复杂的类型</li>
</ul>
<p><code>const</code> 限定的变量需要直接初始化，之后该变量的值不可改变。</p>
<pre><code>const int MONTH = 12;
</code></pre>
<h1 id="auto-声明（自动推断）"><a href="#auto-声明（自动推断）" class="headerlink" title="auto 声明（自动推断）"></a>auto 声明（自动推断）</h1><p>C++11 新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了 auto 的含义。</p>
<p>一般用于处理复杂类型。</p>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 学习之五、C++ 算术运算符</title>
    <url>/2021/06/03/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%94%E3%80%81C-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>每种语言都有类似的运算符，如同数学运算，C++ 基本运算包括加、减、乘、除、除和求模运算。</p>
<span id="more"></span>

<h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><ul>
<li>加法运算，运算符为 “<code>+</code>“。如 <code>4 + 20</code></li>
<li>减法运算，运算符为 “<code>-</code>“。如 <code>20 - 3</code></li>
<li>乘法运算，运算符为 “<code>*</code>“。如 <code>5 * 6</code></li>
<li>除法运算，运算符为 “<code>/</code>“。如 <code>20 / 2</code></li>
<li>求模运算，它等于第一个数除以第二个数后的余数，运算符为 “<code>%</code>“。如 <code>19 % 3</code>，结果为 1</li>
</ul>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>这里只介绍一下基本概念。</p>
<p>如除法运算符表示了 3 种不同的运算：int 除法、float 除法和 double 除法。C++ 根据上下文（这里是操作数的类型）来确定运算符的含义。使用相同的符号进行多种操作叫作运算符重载（operator overloading）。</p>
<h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><p>当两个运算符作用于同一个操作数时，需要考虑先运算哪部分，这里就需要了解运算符优先级。所有的运算优先级如下</p>
<p><img src="/2021/06/03/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%94%E3%80%81C-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="C++ 运算优先级" title="C++ 运算符优先级"></p>
<h1 id="运算时的类型转换"><a href="#运算时的类型转换" class="headerlink" title="运算时的类型转换"></a>运算时的类型转换</h1><p>各种算术运算涉及到的硬件编译指令都是各不相同的，因此计算机需要处理大量不同的情况，尤其对不同的类型进行运算时。为处理这种潜在的混乱，C++ 自动执行很多类型转换：</p>
<ul>
<li>将一种算术类型的值赋给另一种算术类型变量时，C++ 将对值进行转换。</li>
<li>表达式中包含不同类型时，C++ 将对值进行转换。</li>
<li>将参数传递给函数时，C++ 将对值进行转换。</li>
</ul>
<h2 id="初始化和赋值进行的转换"><a href="#初始化和赋值进行的转换" class="headerlink" title="初始化和赋值进行的转换"></a>初始化和赋值进行的转换</h2><p>C++ 允许将一种类型的值赋给另一种类型的变量。该值将被转换为接收变量的类型。如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double a = 3.456;   // a 为 double 类型</span><br><span class="line">int b = a;  // 将 double 类型的值赋给 int 类型，将去掉 double 类型小数部分，所以 b 值为 3</span><br></pre></td></tr></table></figure>

<p>这种类型的转换在一些情况下可能出现问题</p>
<table>
<thead>
<tr>
<th>转换</th>
<th>潜在的问题</th>
</tr>
</thead>
<tbody><tr>
<td>将较大的浮点类型转换为较小的浮点类型，如将 double 转换为 float</td>
<td>精度（有效位数）降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的</td>
</tr>
<tr>
<td>将浮点型转换为整型</td>
<td>小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的</td>
</tr>
<tr>
<td>将较大的整型转换为较小的整型，如将 long 转换为 short</td>
<td>原来的值可能超出目标类型的取值范围，通常只复制右边的字节</td>
</tr>
</tbody></table>
<p><strong>Tips:</strong> 将 0 赋给 bool 变量时，将被转换为 false；而非零值将被转换为 true。</p>
<h2 id="以-方式初始化时进行的转换（C-11）"><a href="#以-方式初始化时进行的转换（C-11）" class="headerlink" title="以 { } 方式初始化时进行的转换（C++11）"></a>以 { } 方式初始化时进行的转换（C++11）</h2><p>C++ 将使用 { } 的初始化称为<strong>列表初始化</strong>（list-initialization），与前一种初始化转换方式相比，它对类型转换的要求更严格。列表初始化不允许缩窄（narrowing），也即不允许将值转换为无法表示该值的变量。例如：</p>
<ul>
<li>不允许浮点型转换为整型。</li>
<li>不同的整型之间的转换或将整型转换为浮点型可能被允许，条件是编译器知道目标变量能够正常地存储赋给它的值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int code = 66;    // const 修饰的常量，code 值固定不可更改</span><br><span class="line">int x = 66;</span><br><span class="line">char c1 &#123;31325&#125;;    // 错误，不允许缩窄</span><br><span class="line">char c2 &#123;66&#125;;   // 无错误，char 类型能处理值 66</span><br><span class="line">char c3 &#123;code&#125;; // 无错误，code 为常量 66，可以被 char 处理</span><br><span class="line">char c4 &#123;x&#125;;    // 错误，区别于上一段代码，x 值虽然为 66，但编译器看来，x 是一个 int 变量，其值可能很大。编译器不会跟踪后面阶段可能发生的情况，此处列表初始化时，并不是严格要求是 const 常量，如果 &#123; &#125; 中为变量，需要求被赋值的变量能处理 &#123; &#125; 中的变量值，例如如果 x 为 char 类型变量，这个初始化则是正确的。</span><br></pre></td></tr></table></figure>

<h2 id="表达式中的转换"><a href="#表达式中的转换" class="headerlink" title="表达式中的转换"></a>表达式中的转换</h2><p>当同一个表达式中包含两种不同的算术类型时，C++ 将执行两种自动转换。首先，一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换。</p>
<h3 id="一些类型在出现时便会进行自动转换"><a href="#一些类型在出现时便会进行自动转换" class="headerlink" title="一些类型在出现时便会进行自动转换"></a>一些类型在出现时便会进行自动转换</h3><p>在计算表达式时，C++ 将 <code>bool</code>、<code>char</code>、<code>unsigned char</code>、<code>signed char</code> 和 <code>short</code> 值转换为 <code>int</code>。具体地说，<code>true</code> 被转换为 1，<code>false</code> 被转换为 0。这些转换被称为整型提升（integral promotion）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">short chickens = 20;</span><br><span class="line">short ducks = 35;</span><br><span class="line">short fowl = chickens + ducks;  // C++ 程序取得 chickens 和 ducks 的值，并将它们转换为 int 类型，计算完后，将值转换为 short 类型赋给 fowl</span><br></pre></td></tr></table></figure>

<p>还有一些其它整型提升：如果 <code>short</code> 比 <code>int</code> 短，则 <code>unsigned short</code> 类型将被转换为 <code>int</code>；如果两种类型的长度相同，则 <code>unsigned short</code> 类型将被转换为 <code>unsigned int</code>。这种规则确保了在对 <code>unsigned short</code> 进行提升时不会损失数据。</p>
<h3 id="将不同的类型进行算术运算时，也会进行一些转换"><a href="#将不同的类型进行算术运算时，也会进行一些转换" class="headerlink" title="将不同的类型进行算术运算时，也会进行一些转换"></a>将不同的类型进行算术运算时，也会进行一些转换</h3><p>当运算涉及到两种类型时，较小的类型将被转换为较大的类型。其中规则为：</p>
<p>long double &gt; double &gt; float &gt; 整型提升</p>
<h2 id="传递参数时的转换"><a href="#传递参数时的转换" class="headerlink" title="传递参数时的转换"></a>传递参数时的转换</h2><p>传递参数时的类型转换通常由 C++ 函数原型控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++ 将对 char 和 short 类型（signed 和 unsigned）应用整型提升。另外，为保持与传统 C 语言中大量代码的兼容性，在将参数传递给取消原型对参数控制的函数时，C++ 将 float 提升为 double。</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>C++ 允许通过强制类型转换机制显式地进行类型转换。</p>
<h3 id="普通强制类型转换语法"><a href="#普通强制类型转换语法" class="headerlink" title="普通强制类型转换语法"></a>普通强制类型转换语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(typeName) value    // 将 value 强制转换为 typeName 类型，如 int(&#x27;Q&#x27;)，兼容 C 语言</span><br><span class="line">typeName (value)    // 如 int (&#x27;Q&#x27;)，C++ 格式</span><br></pre></td></tr></table></figure>

<h3 id="C-引入的-4-个强制类型转换运算符"><a href="#C-引入的-4-个强制类型转换运算符" class="headerlink" title="C++ 引入的 4 个强制类型转换运算符"></a>C++ 引入的 4 个强制类型转换运算符</h3><p>引用的强制类型转换运算符的使用要求较为严格</p>
<p>static_cast&lt;typeName&gt; (value)   // 将 value 转换为 typeName 类型</p>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 教程</title>
    <url>/2021/05/29/VSCode-%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>工欲善其事，必先利其器。简要记录 Windows 下 VS Code 的使用。</p>
<span id="more"></span>

<h1 id="VS-Code-是什么"><a href="#VS-Code-是什么" class="headerlink" title="VS Code 是什么"></a>VS Code 是什么</h1><p><strong>VS Code</strong> 全称是 <strong>Visual Studio Code</strong>，是微软开源的一款多功能文本编辑器，支持丰富的扩展，功能强大，界面美观，适合作为各种编程 IDE。</p>
<ul>
<li>VS Code 命令面板</li>
</ul>
<p>它是 VS Code 快捷键的主要交互界面，可能通过快捷键 <code>Ctrl + Shift + P</code> 打开。然后输入常用指令对 VS Code 进行操作。</p>
<h1 id="VS-Code-键盘操作"><a href="#VS-Code-键盘操作" class="headerlink" title="VS Code 键盘操作"></a>VS Code 键盘操作</h1><ul>
<li><p>光标移动</p>
<ul>
<li>单词的光标移动。<code>Ctrl + 左右方向键</code> 。</li>
<li>光标移动到行首或行末。<code>Home/End</code> 。</li>
<li>代码块花括号移动。光标在代码块花括号上时，按下 <code>Ctrl + Shift + \</code>，就可以在这对花括号之间跳转。</li>
<li>移动到文档首行或最后一行。<code>Ctrl + Home/End</code> 。</li>
</ul>
</li>
<li><p>文本选择</p>
<p>  在光标移动的基础上，多按一个 <code>Shift</code> 键。</p>
</li>
<li><p>删除操作</p>
<ul>
<li>可以先选中文本，再按删除。</li>
<li><code>Ctrl + backspace/Del</code> 删除左/右方向上的单词。</li>
</ul>
</li>
</ul>
<h1 id="VS-Code-代码行编辑"><a href="#VS-Code-代码行编辑" class="headerlink" title="VS Code 代码行编辑"></a>VS Code 代码行编辑</h1><ul>
<li>删除行。<code>Ctrl + Shift + K</code>。</li>
<li>剪切行。<code>Ctrl + X</code>。</li>
<li>重开一行，向下/向上。<code>Ctrl + Enter</code>/<code>Ctrl + Shift + Enter</code></li>
<li>移动代码行。<code>Alt + 上下方向键</code></li>
<li>复制代码行。<code>Alt + Shift + 上下方向键</code></li>
</ul>
<h1 id="VS-Code-撤销光标移动"><a href="#VS-Code-撤销光标移动" class="headerlink" title="VS Code 撤销光标移动"></a>VS Code 撤销光标移动</h1><p>有时候你移动完光标之后，又希望把光标回退到上一个位置，这时你只需按下 <code>Ctrl + U</code>，就可以撤销这一次光标的移动。</p>
<h1 id="VS-Code-行排序"><a href="#VS-Code-行排序" class="headerlink" title="VS Code 行排序"></a>VS Code 行排序</h1><p>无论是你在写代码，还是写 Markdown，你都可以把代码行按照字母序进行重新排序。不过这个命令比较小众，VS Code 并没有给这个命令指定快捷键，你可以调出命令面板，然后搜索 “按升序排列行” 或者 “按降序排列行” 命令执行。</p>
<h1 id="VS-Code-合并代码行"><a href="#VS-Code-合并代码行" class="headerlink" title="VS Code 合并代码行"></a>VS Code 合并代码行</h1><p>有的时候你可能会为了避免代码看起来过于冗余，就会把比较短小的几行代码合并到一行里面去。这时，你可以打开命令面板，搜索“合并行”就可以了，而不需要不断地调整光标、删除换行符。</p>
<h1 id="VS-Code-调整字符大小写"><a href="#VS-Code-调整字符大小写" class="headerlink" title="VS Code 调整字符大小写"></a>VS Code 调整字符大小写</h1><p>我估计这个你会经常用到。你可以选中一串字符，然后在命令面板里运行“转换为大写”或 “转换为小写”, 来变换字符的大小写。</p>
<h1 id="VS-Code-调换字符位置"><a href="#VS-Code-调换字符位置" class="headerlink" title="VS Code 调换字符位置"></a>VS Code 调换字符位置</h1><p>Windows 上未绑定快捷键，可以打开命令面板，搜索 “转置游标处的字符” 来把当前光标前后的字符调换位置。</p>
<h1 id="VS-Code-代码缩进"><a href="#VS-Code-代码缩进" class="headerlink" title="VS Code 代码缩进"></a>VS Code 代码缩进</h1><p>有的时候，你会觉得代码格式化太重了，需要的可能只是把代码里的缩进调整一下。这时你可以打开命令面板，搜索 “缩进”，然后使用 “重新缩进行” 将整个文档的缩进进行调整，但更多时候，你只需要运行 “重新缩进选中行” 来调整部分选中代码行的缩进。</p>
<h1 id="VS-Code-代码格式化"><a href="#VS-Code-代码格式化" class="headerlink" title="VS Code 代码格式化"></a>VS Code 代码格式化</h1><p>你可以按下 <code>Alt + Shift + F</code> 来对整个文档进行格式化，VS Code 也会根据你当前的语言，选择相关的插件。当然，前提条件是你已经安装了相关插件。</p>
<p>你也可以选中一段代码，然后按下 <code>Ctrl + K</code> 或 <code>Ctrl + F</code>，这样只有这段被选中的代码才会被格式化。</p>
<h1 id="VS-Code-添加代码注释"><a href="#VS-Code-添加代码注释" class="headerlink" title="VS Code 添加代码注释"></a>VS Code 添加代码注释</h1><p>你在调试代码时，肯定经常需要临时地把一些代码注释掉。如果你要将一行代码注释掉，你只需按下 <code>Ctrl + /</code>。</p>
<h1 id="VS-Code-自动补全"><a href="#VS-Code-自动补全" class="headerlink" title="VS Code 自动补全"></a>VS Code 自动补全</h1><p>VS Code 当中的自动补全内容，其实是由语言服务来提供的。</p>
<p>VS Code 编程语言工作者提供了纹饰一的 API，即 Language Server Protocol，每种语言都能够通过实现这个 API 在 VS Code 上得到类似 IDE 的开发体验，而各个语言根据这个 API 实现的服务，就被称为<strong>语言服务</strong>。</p>
<h1 id="VS-Code-文本选择"><a href="#VS-Code-文本选择" class="headerlink" title="VS Code 文本选择"></a>VS Code 文本选择</h1><p>在 VS Code 中，你单击鼠标左键就可以把光标移动到相应的位置。而双击鼠标左键，则会将当前光标下的单词选中。连续三次按下鼠标左键，则会选中当前这一行代码。最后是连续四次按下鼠标左键，则会选中整个文档。</p>
<p>到这里你可能会问，如果我想要使用鼠标，选中其中的多行代码该怎么办？VS Code也考虑到了这个情况，在编辑器的最左边，显示的是每一行的行号。如果你单击行号，就能够直接选中这一行。如果你在某个行号上按下鼠标，然后上下移动，则能够选中多行代码。</p>
<h1 id="VS-Code-快速预览"><a href="#VS-Code-快速预览" class="headerlink" title="VS Code 快速预览"></a>VS Code 快速预览</h1><p>VS Code 快速预览是指，有的时候，当我们看到一个建议列表里的某个函数名，我们可能并不能够立刻想起它的作用是什么，它的参数定义是什么样的。这时候我们可以单击当前这一项建议的最右侧的蓝色图标。除了使用鼠标键外，我们还可以使用 “Ctrl+空格键”组合键来快速调出这个快速预览窗口。</p>
<h1 id="VS-Code-参数预览"><a href="#VS-Code-参数预览" class="headerlink" title="VS Code 参数预览"></a>VS Code 参数预览</h1><p>当我们从建议列表选择了一个函数，然后输入括号，准备开始输入参数时，我们会看到一个参数预览的悬浮框。通过这个参数预览的窗口，我们可以知道这个函数可以传入哪些参数，它们的参数类型又是什么样的。</p>
<p>同样的，隐藏这个窗口的快捷键也是 Escape。如果你想再次将其调出的话，需要按下 <code>Ctrl + Shift + Space</code></p>
<h1 id="VS-Code-快速修复"><a href="#VS-Code-快速修复" class="headerlink" title="VS Code 快速修复"></a>VS Code 快速修复</h1><p>语言服务除了在书写代码的时候提供提示以外，还能够帮我们分析当前的代码，检测出他们潜在的问题，然后提供快速修复的方案。在需要修复的行首，看到灯泡图标，点击该图标选择修复内容进行操作，也可以按快捷键 <code>Ctrl + .</code> 来调出这个快速悠的建议列表。</p>
<h1 id="VS-Code-重构"><a href="#VS-Code-重构" class="headerlink" title="VS Code 重构"></a>VS Code 重构</h1><p>当我们想修改一个函数或者变量的名字时候，我们只需把光标放到函数或者变量名上，然后按下 F2，这样这个函数或者变量出现的地方就都会被修改。这个操作并不是一个粗暴的搜索关键词并替换。另一个常用的重构的操作就是把一段长代码抽取出来转成一个单独的函数。在VS Code中，我们只需选中那段代码，点击黄色的灯泡图标，然后选择对应的重构操作即可。</p>
<p>要注意的是，并不是每个语言服务都支持重构的操作。如果你选中一段代码后，但没有看到那个黄色的灯泡图标，那么也就是说你使用的这门语言可能还没有支持快速重构。</p>
<h1 id="VS-Code-文本编辑"><a href="#VS-Code-文本编辑" class="headerlink" title="VS Code 文本编辑"></a>VS Code 文本编辑</h1><p><strong>VS Code 文本编辑</strong>，在 VS Code中，我们除了能够使用鼠标来选择文本以外，还能够使用鼠标对文本进行一定程度的修改，我们把它称为拖放功能（drag and drop）。</p>
<p>比如在今天的示例代码中，我们选中一段函数，然后将鼠标移到这段选中的代码之上，按下鼠标左键不松开。这时你可以看到，鼠标指针已经从一条竖线，变成了一个箭头。这时候我们移动鼠标的话，就可以把这段文本拖拽到我们想要的位置。</p>
<p>在移动的过程当中，我们能够在编辑器中看到一个由虚线构成的光标，当我们松开鼠标左键的时候，这段文本就会被移动到这个虚拟的光标所在的位置。</p>
<p>如果我们在拖拽这段文本的同时，按下 Ctrl 键，鼠标指针上会多一个加号，这时候我们再移动鼠标或虚拟光标至我们想要的位置，然后当我们松开鼠标左键的时候，这段文本将会被复制粘贴到虚拟光标所在的位置，也就是我们既定的目标位置。</p>
<h1 id="VS-Code-多光标"><a href="#VS-Code-多光标" class="headerlink" title="VS Code 多光标"></a>VS Code 多光标</h1><p>在我们的日常编码过程中，有很多工作，它本身就是具有“重复”属性的。比如你需要把多个单词的第一个字母从小写变成大写，这种跟业务逻辑相关的重复性操作，编辑器很难为它们一个个单独做优化。</p>
<p>而 VS Code 的多光标特性其实就是用来解决这类问题的。当你在一个文本框或者某个输入框里打入字符时，会有一个竖线来显示你将要输入文字的位置，这就是“光标”。顾名思义，多光标其实就是多个输入位置，这里你可以脑补下多个竖线的场景。</p>
<p>多光标特性允许你在输入框的多个位置创建光标，这样你就可以在多个不同的位置同时输入文字或者执行其他操作。</p>
<h2 id="使用鼠标"><a href="#使用鼠标" class="headerlink" title="使用鼠标"></a>使用鼠标</h2><p>第一种添加多光标的方式，就是使用鼠标。在键盘上按住 <code>Alt</code>，然后鼠标点第二个想要创建光标的位置，那么第二个光标就创建好了。现在你可以看到两个光标，第二个光标比第一个要细一点。之后想添加其它光标按上面的操作即可。</p>
<h2 id="使用键盘"><a href="#使用键盘" class="headerlink" title="使用键盘"></a>使用键盘</h2><p>首先把光标移动到一个合适位置，按下 <code>Ctrl + Alt + 上/下方向键</code>，就可以在当前光标的上/下位置创建一个光标。</p>
<h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><p><code>Ctrl + D</code>，第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它。</p>
<p><code>Alt + Shift + i</code>，选择多行代码后按下该命令，第一行的最后都会创建一个新的光标。</p>
<h2 id="鼠标中键"><a href="#鼠标中键" class="headerlink" title="鼠标中键"></a>鼠标中键</h2><p>你只需按下鼠标中键，然后对着一段文档拖出一个框，在这个框中的代码就都被选中了，而且每一行被选中的代码，都拥有一个独立的光标。</p>
<h1 id="VS-Code-代码跳转和链接"><a href="#VS-Code-代码跳转和链接" class="headerlink" title="VS Code 代码跳转和链接"></a>VS Code 代码跳转和链接</h1><p>我们把鼠标放到要跳转的代码上，按住 <code>Ctrl</code> 键，这时代码下面出现一个下划线。然后当我们按下鼠标左键，就跳转到函数定义处。</p>
<p>当我们在编写 Markdown 这样的非编程语言的文档时，也可以通过这种方法打开超级链接。</p>
<h1 id="VS-Code-悬停提示窗口"><a href="#VS-Code-悬停提示窗口" class="headerlink" title="VS Code 悬停提示窗口"></a>VS Code 悬停提示窗口</h1><p>当我们的鼠标移动到某些文本上之后，稍等片刻就能看到一个悬停提示窗口。这个窗口里会显示跟鼠标下文本相关的信息。譬如鼠标停留在一个函数上时，它告诉我们这是一个函数，函数的返回值和类型。</p>
<p>当我们按住 <code>Ctrl</code> 然后悬停时，提示窗口会显示该函数的实现。</p>
<h1 id="VS-Code-文件跳转"><a href="#VS-Code-文件跳转" class="headerlink" title="VS Code 文件跳转"></a>VS Code 文件跳转</h1><p>当你在开发一个新功能或者修复一个 Bug 的时候，你同时在阅读和修改的文件可能就有几个或者十几个。从资源管理器里打开文件固然方便，但是如果这个项目里的文件非常多，并且经常需要在资源管理器里寻找文件，那“眼花缭乱”的，肯定要浪费你不少宝贵的时间。</p>
<p>在VS Code中，解决这个问题的第一个方法，就是按下 <code>Ctrl + Tab</code>，然后继续按着 <code>Ctrl</code> 键但是松开 <code>Tab</code> 键，这样你就可以打开一个文件列表，这个列表罗列了当前打开的所有文件。接下来，你可以通过按下 <code>Tab</code> 键在这个列表里跳转，选择你想要打开的文件。最后选到你想打开的文件后，松开 <code>Ctrl</code> 键，这个文件就被打开了。</p>
<p>不过，使用这个方式切换文件，最大的问题在于，文件一旦多了，你就得不停地按 <code>Tab</code> 键，没完没了地上下跳转和挑选，这会是一个恼人的耗费时间和眼力的操作。</p>
<p>还好，VS Code 在命令面板里提供了一种支持搜索的文件跳转方式。当你按下 <code>Ctrl + P</code> 时，就会跳出一个最近打开文件的列表，同时在列表的顶部还有一个搜索框。</p>
<p>看到这里想必你应该明白了，你可以使用这个搜索框来快速地找到你想要的文件，然后按下 <code>Enter</code> 键直接打开，这整个过程简单而且顺畅。</p>
<h1 id="VS-Code-行跳转"><a href="#VS-Code-行跳转" class="headerlink" title="VS Code 行跳转"></a>VS Code 行跳转</h1><p>打开某一个文件之后，你的另外一个需求可能就是要快速跳转到这个文件的某一行。你可能会想，VS Code是不是可以像Vim那样，输入“:13”就能跳转到第13行。是的，VS Code 也提供了一种极为简单的方式来支持行跳转，你只需要按下 <code>Ctrl + g</code>，紧接着编辑器就会出现一个输入框。按下 <code>Ctrl + g</code>，调出行输入框，你会惊喜地发现，这个输入框的第一个字符就是 “ : ”，在这之后输入数字，你就能够将光标快速地移动到那一行。输入行数3，跳转到第3行。</p>
<p>接下来我再给你介绍一个高阶组合技巧。如果你想跳转到某个文件的某一行，你只需要先按下 <code>Cmd + P</code>，输入文件名，然后在这之后加上 “:”和指定行号即可。</p>
<h1 id="VS-Code-符号跳转"><a href="#VS-Code-符号跳转" class="headerlink" title="VS Code 符号跳转"></a>VS Code 符号跳转</h1><p>文件跳转和行跳转，是代码跳转的基本操作，也是日常编码中的高频操作。不过有的时候，你可能会希望能够立刻跳转到文件里的类定义，或者函数定义的位置。为了支持这种跳转，VS Code 提供了一套 API 给语言服务插件，它们可以分析代码，告诉 VS Code 项目或者文件里有哪些类、哪些函数或者标识符（我们把这些统称为符号）。</p>
<p>如果要在一个文件里的符号之间跳转，你只需按下 <code>Ctrl + Shift + O</code>，就能够看到当前文件里的所有符号。</p>
<p>通过 <code>Ctrl + T</code>，可以搜索多个文件中的符号。</p>
<h1 id="VS-Code-定义和实现间跳转"><a href="#VS-Code-定义和实现间跳转" class="headerlink" title="VS Code 定义和实现间跳转"></a>VS Code 定义和实现间跳转</h1><p>符号跳转依托于语言插件对代码的分析，已经算得上具备一定的智能特性，但是它还是不够精确。比如说我们看到某个函数的调用，想要知道这个函数的接口定义是什么样的，它的实现细节是什么样的，光靠符号跳转，还是会不方便。我们需要的是直接跳转到定义和实现的位置，Java程序员看到这里一定会深有感触。</p>
<p>按下 F12，就可以跳转到函数定义处，按下 <code>Ctrl + F12</code> 跳转到函数实现的位置。</p>
<h1 id="VS-Code-跳转到引用的地方"><a href="#VS-Code-跳转到引用的地方" class="headerlink" title="VS Code 跳转到引用的地方"></a>VS Code 跳转到引用的地方</h1><p>很多时候，除了要知道一个函数或者类的定义和实现以外，你可能还希望知道它们被谁引用了，以及在哪里被引用了。这时你只需要将光标移动到函数或者类上面，然后按下 <code>Shift + F12</code>，VS Code 就会打开一个引用列表和一个内嵌的编辑器。在这个引用列表里，你选中某个引用，VS Code 就会把这个引用附近的代码展示在这个内嵌的编辑器里。</p>
<p><code>Shift+ F12</code> 打开函数引用预览。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://geek-docs.com/vscode/vscode-tutorials/what-is-vscode.html" title="极客教程">极客教程 - VSCode 教程</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 学习之六、复合类型之数组</title>
    <url>/2021/06/09/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%AD%E3%80%81%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>C++ 复合类型之数组笔记。</p>
<span id="more"></span>

<h1 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h1><p>数组（array）是一种数据格式，能够存储多个同类型的值。</p>
<h1 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h1><p>声明数组的通用格式如下：</p>
<p><code>typeName arrayName[arraySize]</code></p>
<p><strong>Tips:</strong> <code>arraySize</code> 指定元素数目，它必须是整型常数（如 10 ）或 <code>const</code> 值，也可以是常量表达式（如 <code>8*sizeof( int )</code>），即其中所有的值在编译时都是已知的。具体地说，<code>arraySize</code> 不能是变量。然后后面将介绍使用 <code>new</code> 运算符来避开这种限制。</p>
<p>数组与类型是强关联的，如 <code>float f[20]</code>，f 的类型不是“数组”，而是“float 数组”。</p>
<h1 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h1><p><strong>未初始化的数组的内容是未定义的，只有定义数组时才能初始化，此后就不能使用了，不能将一个数组赋给另一个数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cards[4] = &#123;3, 6, 8, 10&#125;;   // 数组列表初始化</span><br><span class="line">int hand[4];    // 数组声明</span><br><span class="line">hand[4] = &#123;5, 6, 7, 8&#125;  // 错误，只能在上面声明的时候直接初始化，现在的 hand[4] 表示第 5 个元素</span><br><span class="line">hand = cards;   // 错误，不能将一个数组赋给另一个</span><br></pre></td></tr></table></figure>

<p>几种初始化方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float n_float[3] = &#123;0.1, 0.555, 6.8&#125;;   // 列表初始化，可列出所有元素</span><br><span class="line">long n_long[10] = &#123;5, 7&#125;;   // 只列出一部分元素，编译器将把其它元素设置为 0</span><br><span class="line">short n_short[] = &#123;1, 2, 3, 4, 5&#125;;  // 如果 [] 内元素个数为空，C++ 编译器将根据初始化内容来计算元素个数，这里为有 5 个元素，通常这种做法在非初始化 char 数组时不可取，因为不利于排错</span><br><span class="line">double n_double[3]&#123;1.2e12, 1.3e5, 5.9e9&#125;;   // C++11 方式，可省略等号</span><br><span class="line">int n_int[8] = &#123;&#125;;  // C++11 方式，大括号内不包含任何内容，将把所有元素初始化为 0，同上等号也可以省略</span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> 上述所有列表初始化同其它列表初始化一样，禁止缩窄操作。</p>
<h1 id="特殊的数组-字符串"><a href="#特殊的数组-字符串" class="headerlink" title="特殊的数组 - 字符串"></a>特殊的数组 - 字符串</h1><h2 id="C-风格字符串"><a href="#C-风格字符串" class="headerlink" title="C 风格字符串"></a>C 风格字符串</h2><p><code>char</code> 数组中存储多个 <code>char</code> 类型的值，其中有一种特殊情况，如果 <code>char</code> 数组最后一个元素为 <code>\0</code>，即以空字符结尾，这时这个数组就是一个字符串，可以看出，字符串是一种特殊的 <code>char</code> 数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char c_array[5] = &#123;&#x27;z&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;x&#x27;&#125;;    // char 数组</span><br><span class="line">char c_string[5] = &#123;&#x27;z&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;\0&#x27;&#125;;  // 字符串</span><br><span class="line">char c_string[5] = &quot;zhou&quot;;  // 一种更好的初始化字符串的方法，用双引号括起的字符串隐式地包含结尾的空字符，所以元素个数要比双引号的字符个数多 1 个</span><br><span class="line">char c_string[] = &quot;zhou&quot;;   // 初始化字符串时，不写元素个数更方便</span><br><span class="line">char c_string[] = &#123;&quot;zhou&quot;&#125;; // 列表初始化方式</span><br></pre></td></tr></table></figure>

<p>空字符 <code>&#39;\0&#39;</code> 对 C 风格字符串有着至关重要的意义。如 <code>cout</code> 打印字符串时，它将逐个打印字符直到遇到空字符才停止。</p>
<h3 id="C-风格字符串特点一-拼接字面值"><a href="#C-风格字符串特点一-拼接字面值" class="headerlink" title="C 风格字符串特点一 - 拼接字面值"></a>C 风格字符串特点一 - 拼接字面值</h3><p>有时候字符串很长，无法放到一行中。C++ 允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。任何两个由空白（空格、制表符和换行符）分隔的字符串常量将自动拼接成一个，如以下两句意义相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; &quot;This is a&quot; &quot; string&quot;;  // 将自动拼接为 &quot;This is a string&quot;</span><br><span class="line">cout &lt;&lt; &quot;This is a string&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> 如上拼接时，前一个字符串末尾的 “\0” 将被后一个字符串中的第一个字符代替，两者之间不会自动加上空白。</p>
<h3 id="数组中使用字符串"><a href="#数组中使用字符串" class="headerlink" title="数组中使用字符串"></a>数组中使用字符串</h3><p>在数组中使用字符串，最常用的有两种方法——将数组初始化为字符串、将键盘或文件输入读入到数组中。</p>
<p>数组初始化为字符串前面已详细介绍。</p>
<p>而字符串输入，有以下几种方式：</p>
<ul>
<li><code>cin</code> 输入方式。<code>cin</code> 使用空白（空格、制表符和换行符）来确定字符串的结束位置，<code>cin</code> 在获取字符数组输入时只读取一个单词，读取该单词后，<code>cin</code> 将该字符放到数组中，并自动在结尾添加空字符。<code>cin</code> 会将空白保留在输入序列中，但当 <code>cin</code> 将输入转换为整型时，空白不处理也不会有影响。</li>
<li><code>void cin.getline(char *, int)</code>。读取一行输入，直到到达换行符，丢弃换行符。它将使用空字符来替换换行符。</li>
<li><code>void cin.get(char *, int)</code>。读取一行输入，直到到达换行符，将换行符保留在输入序列中。</li>
</ul>
<p><strong>Tips:</strong> <code>strlen()</code> 用于计算可见的字符数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CinInputArray.cpp 通过控制台输入姓名，年龄，身高，体重，判断是否肥胖</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span>  <span class="comment">// 含有 strlen() 函数原型</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bMICal</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;  <span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nameSize = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> name[nameSize] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> weight, height;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;What is your name? &quot;</span>;</span><br><span class="line">    <span class="comment">// 或者使用 cin.getline(name, nameSize); 此时换行符会被丢弃，无需处理</span></span><br><span class="line">    cin.<span class="built_in">get</span>(name, nameSize).<span class="built_in">get</span>();  <span class="comment">//cin.get(name, nameSize) 读入 name，返回 cin 对象，再使用 get() 处理掉换行符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;How old are you? &quot;</span>;</span><br><span class="line">    cin &gt;&gt; age; <span class="comment">// 按理 cin 读取后将留下换行符，但接下来读入的都是数值类型，会忽略换行，所以不处理也可行。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input your weight kg: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; weight;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input your height m: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; height;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You are &quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot;kg&quot;</span> &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot;m&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">bMICal</span>(weight, height);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bMICal</span><span class="params">(<span class="keyword">float</span> weight, <span class="keyword">float</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> bmi = weight / (height * height);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your BMI is &quot;</span> &lt;&lt; bmi &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (bmi &lt; <span class="number">18.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;体重过低！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bmi &gt;= <span class="number">18.5</span> &amp;&amp; bmi &lt;= <span class="number">23.9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;体重正常！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bmi &gt;= <span class="number">24.0</span> &amp;&amp; bmi &lt;= <span class="number">27.9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;超重！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bmi &gt;= <span class="number">28</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;肥胖！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取空行和其他问题</p>
<blockquote>
<p>当 <code>void getline(char *, int)</code> 或 <code>void get(char*, int)</code> 读取空行时，将发生什么情况？当前的做法是，当 <code>void get(char*, int)</code>（不是 <code>getline(char*, int)</code>）读取空行后将设置失效位（failbit）。接下来的输入将被阻断，但可以用下面的命令来恢复输入：</p>
<p><code>cin.clear();</code></p>
<p>另一个问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则 <code>void getline(char*, int)</code> 和 <code>void get(char*, int)</code> 将把余下的字符留在输入队列中，而 <code>void getline(char*, int)</code> 还会设置失效位，并关闭后面的输入。将在后面章节讨论。</p>
</blockquote>
<h2 id="C-string-类"><a href="#C-string-类" class="headerlink" title="C++ string 类"></a>C++ string 类</h2><p>ISO/ANSI C++98 标准通过添加 string 类扩展了 C++ 库，只需要包含头文件 string。<strong>string 类位于名称空间 std 中，因此需要提供一条 using 编译指令。</strong></p>
<h3 id="string-字符串初始化"><a href="#string-字符串初始化" class="headerlink" title="string 字符串初始化"></a>string 字符串初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;This is a string!&quot;</span>;  <span class="comment">// C-风格字符串初始化方式</span></span><br><span class="line">string str2 = &#123;<span class="string">&quot;This is a string!&quot;</span>&#125;;    <span class="comment">// 列表初始化方式</span></span><br></pre></td></tr></table></figure>

<h3 id="string-特性"><a href="#string-特性" class="headerlink" title="string 特性"></a>string 特性</h3><ul>
<li><p>不同于 C-风格字符串只能使用 <code>strcpy()</code> 函数将一个字符串复制给另一个，string 直接可将一个 string 赋给另一个。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;This&quot;</span>;   <span class="comment">// string 对象将根据字符串的长度自动调整自己的大小</span></span><br><span class="line">string str2;    <span class="comment">// 未初始化的 string 对象长度为0</span></span><br><span class="line">str2 = str1;    <span class="comment">// 语法正确</span></span><br></pre></td></tr></table></figure></li>
<li><p>string 类简化了字符串合并操作。</p>
<p>  传统 C-风格字符串使用 <code>strcat()</code> 函数拼接字符串，string 字符串，可以使用运算符 <code>+</code> 将两个 string 对象合并起来，还可以使用 <code>+=</code> 将字符串附加到 string 对象的末尾。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string str3;</span><br><span class="line">str3 = str1 + str2; // str3 为 str1 和 str2 的拼接</span><br><span class="line">str1 += str2;   // 将 str2 附加到 str1 末尾</span><br></pre></td></tr></table></figure></li>
<li><p>string 类 I/O</p>
</li>
</ul>
<p>从输入读取字符串到 string 对象时，每次读取一行，而且是使用以下代码方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(charr, charrSize);  <span class="comment">// C-风格字符串读取输入</span></span><br><span class="line"><span class="built_in">getline</span>(cin, str);  <span class="comment">// string 对象读取输入</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h2><ul>
<li><p>普通类型</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> array[] = <span class="string">&quot;This is array!&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>wchar_t 类型字符串</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> array[] = <span class="string">L&quot;This is array!&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>char16_t 和 char32_t 类型字符串</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char16_t</span> array[] = <span class="string">u&quot;char16_t style array!&quot;</span>;</span><br><span class="line"><span class="keyword">char32_t</span> array[] = <span class="string">U&quot;char32_t style array!&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>C++11 新增一种类型是原始（raw）字符串</p>
<p>  输入原始字符串时，所有的字符以原样显示，特殊字符也不会被转义，按回车键不仅会移动到下一行，还将在原始字符串中添加回车符。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char array[] = R&quot;(This is ray array, \&quot; will not be translate to &quot;.)&quot;;  // 以 R&quot;( 开头，以 )&quot; 结束。</span><br><span class="line">char array[] = R&quot;+-(This is ray array, \&quot; will not be translate to &quot;.)+-&quot;;  // 允许在开头 &quot;( 之间添加除空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）以外的任意数量的基本字符，然后以相同的格式结尾。</span><br></pre></td></tr></table></figure>

<p>  <strong>Tips:</strong> 可将前缀 <strong>R</strong> 与其他字符串前缀结合，以标识 <code>wchar_t</code> 等类型的原始字符串。可将 <strong>R</strong> 放在前面，也可将其放在后面，如 <strong>Ru、UR</strong> 等。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 学习之七、C++ 复合类型之结构、共用体、枚举</title>
    <url>/2021/06/14/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%83%E3%80%81C-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B9%8B%E7%BB%93%E6%9E%84%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>C++ 的结构、共用体、枚举等有一些共同之处，也有很多差别。</p>
<span id="more"></span>

<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="结构概念"><a href="#结构概念" class="headerlink" title="结构概念"></a>结构概念</h2><p>数组是存储一组相同类型的数据，如果想在一个对象中存储多种不同类型的数据呢，比如想同时存储一个人的姓名，年龄，身高，体重。</p>
<p>结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据。结构也是 C++ OOP (类) 的基石。</p>
<h2 id="结构声明"><a href="#结构声明" class="headerlink" title="结构声明"></a>结构声明</h2><p>结构声明包括两步。首先，定义结构描述——它描述并标记了能够存储在结构中的各种数据类型。然后按描述创建结构变量（结构数据对象）。</p>
<p>结构声明放置的位置决定作用范围，使用与基本类型变量一致，这在以后将讨论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StructDemo.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>   // 外部声明 <span class="title">person</span> 结构，其它函数中都可以使用，如果是某个函数内部声明，则只能该函数内部使用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">// 成员 name</span></span><br><span class="line">    <span class="keyword">bool</span> sex;   <span class="comment">// 性别，true 表示男</span></span><br><span class="line">    <span class="keyword">int</span> age;    <span class="comment">// 成员 age</span></span><br><span class="line">    <span class="keyword">float</span> height;   <span class="comment">// 成员 height: m</span></span><br><span class="line">    <span class="keyword">float</span> weight;   <span class="comment">// 成员 weight: kg</span></span><br><span class="line">&#125;;  <span class="comment">// 注意结构声明中每个成员都以分号隔开，最后的大括号后面也要有分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    person xiaoming = </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Xiao Ming&quot;</span>,</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">        <span class="number">30</span>,</span><br><span class="line">        <span class="number">1.70</span>,</span><br><span class="line">        <span class="number">68</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 结构变量使用成员运算符（.）来访问各个成员</span></span><br><span class="line">    cout &lt;&lt; xiaoming.name &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; xiaoming.age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;And he is &quot;</span> &lt;&lt; xiaoming.height &lt;&lt; <span class="string">&quot;m, &quot;</span> &lt;&lt; xiaoming.weight &lt;&lt; <span class="string">&quot;kg.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构类型变量初始化"><a href="#结构类型变量初始化" class="headerlink" title="结构类型变量初始化"></a>结构类型变量初始化</h2><p>定义结构后，就可以像声明基本数据类型变量一样使用结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">person teacher = </span><br><span class="line">&#123;   <span class="comment">// 一般初始化方式，成员之间使用 , 分隔</span></span><br><span class="line">    <span class="string">&quot;Xiao Zhang&quot;</span>,    <span class="comment">// name</span></span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="number">50</span>,     <span class="comment">// age</span></span><br><span class="line">    <span class="number">1.68</span>,   <span class="comment">// height</span></span><br><span class="line">    <span class="number">68</span>     <span class="comment">// weight，最后一个数据可以不使用 , 分隔</span></span><br><span class="line">&#125;;  <span class="comment">// 初始化最后大括号依然使用分号</span></span><br><span class="line"></span><br><span class="line">person teacher &#123;<span class="string">&quot;Xiao Zhang&quot;</span>, <span class="literal">false</span>, <span class="number">50</span>, <span class="number">1.68</span>, <span class="number">68</span>&#125;; <span class="comment">// C++11 列表初始化方式，可以省略 = 号</span></span><br><span class="line"></span><br><span class="line">person teacher &#123;&#125;;  <span class="comment">// C++11 列表初始化方式，大括号内未包含任何内容时，各个成员都将被设置为零，name 每个字节都将设置为 0</span></span><br></pre></td></tr></table></figure>

<p>可以在声明结构的同时定义出该类型的变量，或直接初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pages;</span><br><span class="line">    <span class="keyword">char</span> bookName[<span class="number">20</span>];</span><br><span class="line">&#125; book1, book2; <span class="comment">// 直接定义 book1 book2 为 book 结构类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pages;</span><br><span class="line">    <span class="keyword">char</span> bookName[<span class="number">20</span>];</span><br><span class="line">&#125; book3 =       <span class="comment">// 定义出 book 结构类型变量 book3 并直接初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">200</span>,</span><br><span class="line">    <span class="string">&quot;Driving&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  // 没有名称的结构，匿名结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; position;     <span class="comment">// 结构变量，这种声明方法最终只能使用直接定义的变量，后面无法创建该结构的新变量</span></span><br></pre></td></tr></table></figure>

<h2 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h2><p>如上述例子中，结构中可以包含数组（如 name[20]），也可创建元素为结构的数组，方法和创建基本类型数组一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如创建 person 结构数组</span></span><br><span class="line">person teacher[<span class="number">3</span>] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Xiao Hong&quot;</span>, <span class="literal">false</span>, <span class="number">20</span>, <span class="number">1.50</span>, <span class="number">45</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Xiao Wang&quot;</span>, <span class="literal">true</span>, <span class="number">25</span>, <span class="number">1.80</span>, <span class="number">70.2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Xiao Cheng&quot;</span>, <span class="literal">false</span>, <span class="number">18</span>, <span class="number">1.50</span>, <span class="number">43</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; teracher[<span class="number">0</span>].name &lt;&lt; endl;   <span class="comment">// 像使用正常数组一们使用结构数组</span></span><br></pre></td></tr></table></figure>

<h2 id="结构中的位字段"><a href="#结构中的位字段" class="headerlink" title="结构中的位字段"></a>结构中的位字段</h2><p>与 C 语言一样，C++ 也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。字段的类型应为整数或枚举，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个成员都被称为位字段（bit field）。下面是一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">torgle_register</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SN : <span class="number">4</span>;    <span class="comment">// 4 bits for SN value</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> : <span class="number">4</span>;   <span class="comment">// 4 bits 未使用数据，用来占位提供间距</span></span><br><span class="line">    <span class="keyword">bool</span> goodIn : <span class="number">1</span>;    <span class="comment">// valid input (1 bit)</span></span><br><span class="line">    <span class="keyword">bool</span> goodTorgle: <span class="number">1</span>; <span class="comment">// success ful torgling</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以像通常那样初始化这些字段，还可以使用标准的结构表示法来访问位字段：</span></span><br><span class="line">torgle_register tr = &#123; <span class="number">14</span>, <span class="literal">true</span>, <span class="literal">false</span> &#125;;   <span class="comment">// 不用管未命名的占位字段</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (tr.goodIN)  <span class="comment">// 获得成员来进行判断</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="共用体-union"><a href="#共用体-union" class="headerlink" title="共用体 union"></a>共用体 union</h1><p>共用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。共用体的句法和结构相似，但含义不同。共用体的用途之一是，当数据使用两种或更多格式（但不会同时使用）时，可节省空间。另外，共用体常用于操作系统数据结构或硬件数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 UnionDemo.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goods</span>    // 定义 <span class="title">Goods</span> 结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> type;  <span class="comment">// 结构成员 type</span></span><br><span class="line">    <span class="keyword">float</span> weight;   <span class="comment">// 结构成员 weight</span></span><br><span class="line">    <span class="keyword">float</span> height;   <span class="comment">// 结构成员 height</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">id</span>    // 结构成员 <span class="title">id</span> 是一个共用体，只能存储定义中的其中一种类型</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">double</span> d_id;</span><br><span class="line">        <span class="keyword">int</span> int_id;</span><br><span class="line">    &#125; id_var;   <span class="comment">// struct 内嵌套 union 使用时，union 需要直接定义出共用体类型的变量，否则无法正常使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Goods first;</span><br><span class="line">    first.type = <span class="literal">true</span>;</span><br><span class="line">    first.weight = <span class="number">1.3</span>;</span><br><span class="line">    first.height = <span class="number">0.5</span>;</span><br><span class="line">    first.id_var.d_id = <span class="number">1.6888</span>; <span class="comment">// 赋值 d_id，则此 union 内存中无 int_id</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID is &quot;</span> &lt;&lt; first.id_var.d_id &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当共用体中一个成员被赋值后，其它成员将像不存在一样。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以共用体的长度为其最大成员的长度。</p>
<p>union 还有一种匿名类型，像匿名结构一样不需要名字，此时不需要定义该变量。此时由于共用体是匿名的，因此共用体的成员将被视为外部成员，它们的地址相同，所以不需要变量来标识。程序员负责确定当前哪个成员是活动的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> brand[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>   // 匿名共用体</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">long</span> id_num;</span><br><span class="line">        <span class="keyword">char</span> id_char[<span class="number">20</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">widget prize;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// id_num 和 id_char 被视为 prize 的两个成员，id_num 和 id_char 地址相同</span></span><br><span class="line"><span class="keyword">if</span> (prize.type == <span class="number">1</span>)</span><br><span class="line">    cin &gt;&gt; prize.id_num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cin &gt;&gt; prize.id_char;</span><br></pre></td></tr></table></figure>

<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>C++ 的枚举（enum）工具提供了另一种创建符号常量的方式，这种方式可以代替 <code>const</code>。它还允许定义新类型，但必须按严格的限制进行。使用 enum 的句法与使用结构相似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum spectrum</span><br><span class="line">&#123;</span><br><span class="line">    red, orange, yellow, green, blue, violet, indigo, ultraviolet</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>spectrum</code> 被称为枚举。大括号内将作为符号常量，它们对应的整数值 0 ~ 7。这些常量叫作枚举量（enumerator）。</p>
<h2 id="枚举的特性"><a href="#枚举的特性" class="headerlink" title="枚举的特性"></a>枚举的特性</h2><ul>
<li><p>默认情况下，将整数值赋给枚举量，第一个值为 0，第二个值为 1，依此类推。如上例中 red 值为 0，orange 值为 1。</p>
</li>
<li><p>在不进行强制转换的情况下，只能将定义的枚举量赋值给相应的枚举变量，如</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spectrum band;  // 定义 spectrum 类型的枚举变量 band</span><br><span class="line">band = blue;    // 正确，band 变量的值只能为定义的枚举量</span><br><span class="line">band = 2000;    // 非法，2000 不是定义的枚举量，不能赋给枚举变量</span><br></pre></td></tr></table></figure></li>
<li><p>枚举量是整型，可被提升为 int 类型，但 int 类型不能自动转换为枚举类型。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int color = orange; // 合法，枚举量可提升为整型</span><br><span class="line">band = 3;   // 非法，int 类型不能自动转换为枚举类型</span><br><span class="line">color = 3 + red;    // 合法，red 提升为 int 类型</span><br></pre></td></tr></table></figure>

<p>  但是在枚举量的取值范围内的时候，int 类型可以强制转换为枚举量。如 <code>band = spectrum(3)</code></p>
</li>
</ul>
<h2 id="枚举量的值"><a href="#枚举量的值" class="headerlink" title="枚举量的值"></a>枚举量的值</h2><p>可以使用赋值运算符来显式地设置枚举量的值：</p>
<p><code>enum bits&#123;one = 1, two = 2, four = 4, eight = 8&#125;;</code></p>
<p>指定的值必须是整数。也可以只显式地定义其中一些枚举量的值：</p>
<p><code>enum bigstep&#123;first, second = 100, third&#125;;</code></p>
<p>这里，first 在默认情况下为 0。后面没有被初始化的枚举量的值将比其前面的枚举量大 1。因此 third 的值为 101。</p>
<p>最后，可以创建多个值相同的枚举量：</p>
<p><code>enum step&#123;zero, null = 0, one, numro_uno = 1&#125;</code></p>
<p>其中 <code>zero</code> 和 <code>null</code> 都为 <code>0，one</code> 和 <code>numro_uno</code> 都为 1。</p>
<h2 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h2><p>可以将在枚举取值范围内的整型强制转换为枚举量。</p>
<ul>
<li>上限。大于最大枚举量的、最小的 2 的幂，将它减去 1。如枚举量中最大值为 11，则此枚举上限为 15</li>
<li>下限。如果枚举量最小值不小于 0，则取值范围的下限为 0，否则，采用与寻找上限方式相同的方法，但加上负号。如，假如最小的枚举量为 -6，而比它小的、最大的 2 的幂是 -8（加上负号），因此下限为 -7。</li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 学习之八、复合类型之指针</title>
    <url>/2021/06/22/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%AB%E3%80%81C-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>指针是一个在 C 和 C++ 语言中很重要的概念。</p>
<span id="more"></span>

<h1 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h1><p>指针是用于存储值的地址的变量。</p>
<p>对于常规变量，值是指定的量，而地址是派生量，地址值可通过对变量应用地址运算符（&amp;）取得。</p>
<p>对于指针刚好相反，将地址视为指定的量，而将值视为派生量。<code>*</code> 运算符被称为间接值或解除引用运算符，将其应用于指针，可以得到该地址处存储的值。</p>
<h1 id="指针初始化"><a href="#指针初始化" class="headerlink" title="指针初始化"></a>指针初始化</h1><p>指针与数组一样都是与类型强关联的。如 <code>int *pt</code> 表示 <code>int</code> 类型的指针 <code>pt</code>。</p>
<p><strong>Tips: 一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址，这是关于使用指针的金科玉律。</strong></p>
<h2 id="先声明再赋值"><a href="#先声明再赋值" class="headerlink" title="先声明再赋值"></a>先声明再赋值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">1000</span>;    <span class="comment">// temp 为 int 类型</span></span><br><span class="line"><span class="keyword">int</span> *pt;    <span class="comment">// 声明 int 指针 pt，也可写成 int * pt，空格在哪里都可以，或者不写空格</span></span><br><span class="line">pt = &amp;temp; <span class="comment">// 将 temp 变量的地址赋值给 int 指针 pt</span></span><br></pre></td></tr></table></figure>

<h2 id="声明时直接赋值"><a href="#声明时直接赋值" class="headerlink" title="声明时直接赋值"></a>声明时直接赋值</h2><p>注意此语法是给指针赋值，并不是给指针指向的值赋值。此种类型初始化同样适用于使用 new 初始化指针时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> *pt = &amp;temp;    <span class="comment">// 注意此时是给 int 指针 pt 赋值，而不是 *pt（指针指向的值）</span></span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> 声明多个指针时，每个指针变量都要有一个 <code>*</code>，注意区别：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pt1, pt2;  <span class="comment">//声明 int 指针 pt1 和 int 整型 pt2</span></span><br><span class="line"><span class="keyword">int</span> *pt1, *pt2; <span class="comment">// 这才是声明两个 int 指针 pt1 和 pt2，所以为防止错误 * 最好跟着变量名一起</span></span><br></pre></td></tr></table></figure>

<h1 id="指针的特性"><a href="#指针的特性" class="headerlink" title="指针的特性"></a>指针的特性</h1><h2 id="指针与整数"><a href="#指针与整数" class="headerlink" title="指针与整数"></a>指针与整数</h2><p>指针不等同于整数，即使指针变量中存储的地址值确实是一个整数，但从概念上看，这两个是截然不同的类型。</p>
<p>整数是可以执行加、减、乘、除等算术运算的数字，而指针描述的是位置，将两个地址相乘除没有任何意义，因此，不能简单地将整数赋给指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pt;</span><br><span class="line">pt = <span class="number">0xB8000000</span>;    <span class="comment">// 语法错误，不能直接将整数赋值给指针</span></span><br><span class="line">pt = (<span class="keyword">int</span> *)<span class="number">0xB8000000</span>; <span class="comment">// 语法正确，实在要将一个整数赋给指针变量，可以使用强制类型转换</span></span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> <code>pt</code> 是 int 值的地址并不意味着 <code>pt</code> 本身的类型是 int，例如，在有些平台中，int 类型是个 2 字节值，而地址是个 4 字节值。</p>
<h2 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h2><p>如上所述，指针中存储的是地址值，将两个地址相乘除是没有任何意义的。但指针是可以进行加减运算的。</p>
<p>指针加 1 的结果等于原来的地址值加上指向的对象占用的字节数。同理减 1 类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;temp; <span class="comment">// 如果 int 为 4 个字节，p=0x123，此时 P+1=0x127</span></span><br></pre></td></tr></table></figure>

<p>还可以将一个指针减去另外一个指针，获得两个指针的差，这将运算将得到一个整数，仅当两个指针指向同一个数组（也可以指向超出结尾的一个位置）时，这种运算才有意义，这将得到两个元素的间隔。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tacos[<span class="number">10</span>] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">90</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">90</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *pt = tacos;    <span class="comment">// int 指针 pt 指向数组的第一个元素</span></span><br><span class="line">pt = pt + <span class="number">1</span>;    <span class="comment">// 加 1 后指向数组的第二个元素 2</span></span><br><span class="line"><span class="keyword">int</span> *pe = &amp;tacos[<span class="number">9</span>];    <span class="comment">// int 指针 pe 指向数组的第十个元素</span></span><br><span class="line">pe = pe - <span class="number">1</span>;    <span class="comment">// 减 1 后指向数组的第九个元素 1</span></span><br><span class="line"><span class="keyword">int</span> diff = pe - pt; <span class="comment">// diff 等于 7，这两个指针相隔七个元素，注意相减的结果并不是这两个指针相差的字节数，而是元素个数</span></span><br></pre></td></tr></table></figure>

<h1 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h1><p>在 C 语言中使用库函数 <code>malloc()</code> 来分配内存，在 C++ 中仍然可以这样做，但更推荐使用 new 运算符。</p>
<p>使用 new 运算符在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。</p>
<h2 id="初始化为基本类型对象内存地址"><a href="#初始化为基本类型对象内存地址" class="headerlink" title="初始化为基本类型对象内存地址"></a>初始化为基本类型对象内存地址</h2><p>语法：typeName * pointer_name = new typeName;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pt = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">// new 运算符初始化指针</span></span><br></pre></td></tr></table></figure>

<p><code>new int</code> 告诉程序，需要适合存储 <code>int</code> 的内存。<code>new</code> 运算符根据类型来确定需要多少字节的内存，然后，它找到这样的内存，并返回其地址。接下来，将地址赋给 pt，pt 是被声明为指向 int 的指针。（如果因为各种原因，new 运算符无法取得所需要的地址时，将返回一个空指针）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use_new.cpp -- new 运算符应用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> nights = <span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">int</span> *pt = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">// new 运算符给 int 指针 pt 分配内存</span></span><br><span class="line">    *pt = <span class="number">1001</span>; <span class="comment">// 分配的内存中存储一个 int 值</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;nights value = &quot;</span> &lt;&lt; nights &lt;&lt; <span class="string">&quot;: location &quot;</span> &lt;&lt; &amp;nights &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int value = &quot;</span> &lt;&lt; *pt &lt;&lt; <span class="string">&quot;: location &quot;</span> &lt;&lt; pt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> *pd = <span class="keyword">new</span> <span class="keyword">double</span>;    <span class="comment">// new 运算符给 double 指针 pd 分配内存</span></span><br><span class="line">    *pd = <span class="number">10000001.0</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double value = &quot;</span> &lt;&lt; *pd &lt;&lt; <span class="string">&quot;: location &quot;</span> &lt;&lt; pd &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;location of pointer pd: &quot;</span> &lt;&lt; &amp;pd &lt;&lt; endl;  <span class="comment">// 打印存储指针变量 pd 的值的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pt;  <span class="comment">// 使用 delete 释放内存 pt</span></span><br><span class="line">    <span class="keyword">delete</span> pd;  <span class="comment">// 使用 delete 释放内存 pd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要内存时，可以使用 <code>new</code> 来请求，使用完内存后，使用 <code>delete</code> 来释放内存，归还或释放的内存可供程序的其他部分使用。使用 <code>delete</code> 时，后面要加上指向内存块的指针（这些内存块最初是用 <code>new</code> 分配的）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ps = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">// 给 int 指针 ps 分配内存</span></span><br><span class="line">*ps = <span class="number">1001</span>; <span class="comment">// 向分配的内存中存储 int 值</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;  <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>

<p>这将释放 ps 指向的内存，但不会删除指针 ps 本身。可以将 ps 重新指向另一个新分配的内存块。</p>
<p>注意一定要配对地使用 new 和 delete；否则将发生内存泄漏（memory leak），也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多的内存而终止。</p>
<p>不要尝试释放已经释放的内存块，C++ 标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。另外，不能使用 delete 来释放声明变量所获得的内存：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ps = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">delete</span> ps;  <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">delete</span> ps;  <span class="comment">// not OK，不要释放已经释放的内存</span></span><br><span class="line"><span class="keyword">int</span> jugs = <span class="number">5</span>;   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">int</span> *pi = &amp;jugs;    <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">delete</span> pi;  <span class="comment">// 语法错误，int 指针 pi 所指向的内存不是由 new 运算符分配的，不能使用 delete 释放内存</span></span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> 只能使用 delete 来释放使用 new 分配的内存。然而，对空指针使用 delete 是安全的。</p>
<p>使用 delete 的关键在于，将它用于 new 分配的内存，这意味着使用 new 分配的内存不管怎么分配，最终都可以使用 delete 释放，不是一定要使用 new 运算符的内存才能使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">int</span> * pq = ps;  <span class="comment">// int 指针 pq 也指向 ps 所指的内存</span></span><br><span class="line"><span class="keyword">delete</span> pq;  <span class="comment">// 语法正确，可以释放该内存，但通常不要创建两个指向同一个内存块的指针</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化为复合数据类型地址"><a href="#初始化为复合数据类型地址" class="headerlink" title="初始化为复合数据类型地址"></a>初始化为复合数据类型地址</h2><p>如果程序只需要一个值，则可能会声明一个简单变量，这样也便于理解和管理。但是，通常对于大型数据（如数组、字符串和结构），应使用 <code>new</code> 运算符来动态分配内存，达到灵活的目的。使用 new[] 运算符创建数组时，将采用动态联编（动态数组），即将在运行时为数组分配空间，其长度也将在运行时设置，还可以将长度设置为变量赋值。使用完这种数组后，应使用 delete[] 释放占用的内存。</p>
<h3 id="使用-new-创建动态数组"><a href="#使用-new-创建动态数组" class="headerlink" title="使用 new 创建动态数组"></a>使用 new 创建动态数组</h3><p>语法：type_name * pointer_name = new type_name[num_elements];</p>
<p>new 运算符将返回第一个元素的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_int = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];   <span class="comment">// 初始化一个指向 int 数组的指针，该指针指向数组的第一个元素</span></span><br></pre></td></tr></table></figure>

<p>释放 new 创建的数组地址：<code>delete [] p_int;</code>，使用 new[] 为数组分配的内存，则应使用 delete[] 来释放。</p>
<h4 id="使用动态数组"><a href="#使用动态数组" class="headerlink" title="使用动态数组"></a>使用动态数组</h4><p>创建动态数组后，如何使用它呢？</p>
<p>C 和 C++ 内部都使用指针来处理数据，数组和指针基本等价。通常，使用数组表示法时，C++ 都执行以下转换：</p>
<p>arrayname[i] 转换为 *(arrayname + i)    // arrayname 为数组名</p>
<p>如果使用指针，而不是数组名，则 C++ 也将执行同样的转换：</p>
<p>pointername[i] 转换为 *(pointername + i)    // pointername 为指向数组的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_some = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">*p_some = <span class="number">1</span>;    <span class="comment">// 指向数组中第一个元素，此时相当于给数组中第一个元素赋值为 1；</span></span><br><span class="line">*(p_some + <span class="number">1</span>) = <span class="number">17</span>; <span class="comment">// 使用指向数组的指针时，指针加 1 将全指针批向下一个元素，此时相当于给数组中第二个元素赋值为 17</span></span><br><span class="line">psome[<span class="number">2</span>] = <span class="number">36</span>;  <span class="comment">// C 和 C++ 内部都使用指针来处理数组，数组和指针基本等价，此时相当于给数组中第三个元素赋值为 36；</span></span><br></pre></td></tr></table></figure>

<h4 id="指针与数组的区别"><a href="#指针与数组的区别" class="headerlink" title="指针与数组的区别"></a>指针与数组的区别</h4><p>C 和 C++ 将数组名解释为第一个元素的地址，所以指针和数组基本等价，都可以使用下标来访问数组元素，但两者之间还是有一些微小的差别的。</p>
<ul>
<li><p>指针是一个变量，数组名相当于是一个常量。指针和数组加 1 都将指向下一个元素，但能重新给指针赋值，但将值赋给数组名是不合法的。</p>
</li>
<li><p>sizeof 运算符。对数组应用 sizeof 运算符得到的是整个数组占用的字节数，而对指针应用 sizeof 得到的是指针变量的长度。这种情况下，C++ 不会将数组名解释为地址，自然也不会解释为第 0 个元素的地址。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *array_point = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> array[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(array_point);    <span class="comment">// 打印出指针变量 array_point 的长度</span></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(array);  <span class="comment">// 打印出整个 array 占用字节数，如果 int 在这个系统中占用 4 个字节，sizeof(array) 值就为 40</span></span><br></pre></td></tr></table></figure></li>
<li><p>对数组取地址时，数组名也不会被解释为其地址。数组名被解释为第 1 个元素的地址，而对数组名应用地址运算符（&amp;）时，将得到的是整个数组的地址：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> tell[<span class="number">10</span>]; <span class="comment">// tell 是一个 20 个字节的 short 数组</span></span><br><span class="line">cout &lt;&lt; tell &lt;&lt; endl;   <span class="comment">// 打印第一个元素的地址，&amp;tell[0]</span></span><br><span class="line">cout &lt;&lt; &amp;tell &lt;&lt; endl;  <span class="comment">// 打印整个数组的地址</span></span><br></pre></td></tr></table></figure>
<p>  从数字上说，这两个地址相同，但从概念上说，&amp;tell[0] （即 tell ）是一个 2 字节内存块的地址，而 &amp;tell 是一个 20 字节内存块的地址。因此 tell+1 将地址加 2，而表达式 &amp;tell+1 将地址加 20。</p>
</li>
</ul>
<h4 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h4><p>我们知道字符串是一种特殊的 char 数组。在 C++ 中，用引号括起的字符串也像数组名一样，表示第 1 个元素的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> flower[<span class="number">10</span>] = <span class="string">&quot;rose&quot;</span>;</span><br><span class="line">cout &lt;&lt; flower &lt;&lt; <span class="string">&quot;s are red\n&quot;</span>;    <span class="comment">// 给 cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。</span></span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> 在 cout 和多数 C++ 表达式中，char 数组名、char 指针以及用引用括起的字符串常量被解释为字符串第一个字符的地址。</p>
<p>所以引出另外一个问题。一般来说，如果给 cout 提供一个指针，它将打印该指针变量的地址值。但如果指针的类型为 char*，则 cout 将显示指针指向的字符串。如果要显示的是字符串的地址，则必须将这种指针强制转换为另一种指针类型。</p>
<h3 id="使用-new-创建动态结构"><a href="#使用-new-创建动态结构" class="headerlink" title="使用 new 创建动态结构"></a>使用 new 创建动态结构</h3><p>在运行时创建数组优于在编译时创建数组，对于结构也是如此。需要在程序运行时为结构分配所需的空间，这也可以使用 new 运算符来完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newstrct.cpp -- 使用 new 运算符来创建结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span>   // 定义一个结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    inflatable * ps = <span class="keyword">new</span> inflatable;   <span class="comment">// 为结构指针分配内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter name of inflatable itme: &quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(ps-&gt;name, <span class="number">20</span>);  <span class="comment">// 箭头运算符访问成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter volume in cubic feet: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; (*ps).volume;    <span class="comment">// *ps 就表示结构实体，使用句点运算符访问成员</span></span><br><span class="line">    cout &lt;&lt;  <span class="string">&quot;Enter price: $&quot;</span>;</span><br><span class="line">    cin &gt;&gt; ps-&gt;price;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; (*ps).name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume: &quot;</span> &lt;&lt; ps-&gt;volume &lt;&lt; <span class="string">&quot; cubic feet\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Price: $&quot;</span> &lt;&lt; ps-&gt;price &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ps;  <span class="comment">// 释放 new 分配的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> 应使用句点运算符还是箭头运算符，规则非常简单，如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构的指针，则使用箭头运算符。</p>
<h1 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h1><p>根据用于分配内存的方法，C++ 有 3 种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在时间的长短方面，以 3 种方式分配的数据对象各不相同。先简要概括这些知识。</p>
<h2 id="自动存储"><a href="#自动存储" class="headerlink" title="自动存储"></a>自动存储</h2><p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量（automatic variable），这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。</p>
<p>实际上，自动变量是一个局部变量，其作用域为包含它的代码块。</p>
<p>自动变量通常存储在<strong>栈内存</strong>中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为<strong>后进先出（LIFO）</strong>。因此，在程序执行过程中，栈将不断地增大和缩小。</p>
<h2 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h2><p>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字 <code>static</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> fee = <span class="number">56.50</span>;</span><br></pre></td></tr></table></figure>

<p>自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定函数被执行时存在（自动变量）。</p>
<h2 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h2><p><code>new</code> 和 <code>delete</code> 运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在 C++ 中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。new 和 delete 让我们可以自由控制内存的分配和释放，可以在这个函数中分配内存，到另一个函数中再释放，但通常不那么做。因此，数据的生命周期不完全受程序或函数的生存时间控制。与使用常规变量相比，使用 new 和 delete 让程序员对程序如何使用内存有更大的控制权，然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的，但 new 和 delete 的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。</p>
<p><strong>Tips:</strong> 要避免内存泄漏问题，最好养成同时使用 new 和 delete 运算符，在自由存储空间上动态分配内存，随后便释放它。C++ 后续学习智能指针有助于自动完成这种任务。</p>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
